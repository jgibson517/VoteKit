{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to VoteKit's documentation!","text":"<p>VoteKit is a Swiss army knife for computational social choice research.</p> <p>Version: 1.0.2 Date: September 10, 2023</p> <p>Helpful links: Source Repository | Documentation | Issues | MGGG.org</p> <p> </p>"},{"location":"#installation","title":"Installation","text":"<p>Votekit can be installed through any standard package management tool:</p> <pre><code>pip install votekit\n</code></pre> <p>or</p> <pre><code>poetry add votekit\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>A simple example of how to use VoteKit to load, clean, and run an election using real data taken from the 2013 Minneapolis Mayoral election. For a more comprehensive walkthrough, read Getting started with VoteKit. </p> <pre><code>from votekit load_csv, remove_noncands\nfrom votekit.elections import STV, fractional_transfer\n\nminneapolis_profile = load_csv(\"mn_2013_cast_vote_record.csv\")\n\n# clean downloaded file to remove edited aspects of the cast vote record\nminneapolis_profile = remove_noncands(minneapolis_profile, [\"undervote\", \"overvote\", \"UWI\"])\n\nminn_election = STV(profile = minneapolis_profile, transfer = fractional_transfer, seats = 1)\nminn_election.run_election()\n</code></pre> <pre><code>                   Candidate     Status  Round\n                BETSY HODGES    Elected     35\n                 MARK ANDREW Eliminated     34\n                 DON SAMUELS Eliminated     33\n                  CAM WINTON Eliminated     32\n          JACKIE CHERRYHOMES Eliminated     31\n                    BOB FINE Eliminated     30\n                   DAN COHEN Eliminated     29\n          STEPHANIE WOODRUFF Eliminated     28\n             MARK V ANDERSON Eliminated     27\n                   DOUG MANN Eliminated     26\n                  OLE SAVIOR Eliminated     25\n               JAMES EVERETT Eliminated     24\n           ALICIA K. BENNETT Eliminated     23\n  ABDUL M RAHAMAN \"THE ROCK\" Eliminated     22\n        CAPTAIN JACK SPARROW Eliminated     21\n           CHRISTOPHER CLARK Eliminated     20\n                   TONY LANE Eliminated     19\n                JAYMIE KELLY Eliminated     18\n                  MIKE GOULD Eliminated     17\n             KURTIS W. HANNA Eliminated     16\n CHRISTOPHER ROBIN ZIMMERMAN Eliminated     15\n         JEFFREY ALAN WAGNER Eliminated     14\n                 NEAL BAXTER Eliminated     13\n            TROY BENJEGERDES Eliminated     12\n            GREGG A. IVERSON Eliminated     11\n            MERRILL ANDERSON Eliminated     10\n                  JOSHUA REA Eliminated      9\n                   BILL KAHN Eliminated      8\n         JOHN LESLIE HARTWIG Eliminated      7\n      EDMUND BERNARD BRUYERE Eliminated      6\nJAMES \"JIMMY\" L. STROUD, JR. Eliminated      5\n            RAHN V. WORKCUFF Eliminated      4\n       BOB \"AGAIN\" CARNEY JR Eliminated      3\n                  CYD GORMAN Eliminated      2\n         JOHN CHARLES WILSON Eliminated      1\n</code></pre>"},{"location":"#development-and-contribution","title":"Development and Contribution","text":"<p>This project is in active development in the mggg/VoteKit GitHub repository, where bug reports and feature requests, as well as contributions, are welcome.</p> <p>VoteKit project requires <code>poetry</code>, and Python &gt;= 3.9. (This version chosen somewhat arbitrarily.)</p> <p>To get up and running, run <code>poetry install</code> from within the project directory to install all dependencies. This will create a <code>.venv</code> directory that will contain dependencies. You can interact with this virtualenv by running your commands prefixed with <code>poetry run</code>, or use <code>poetry shell</code> to activate the virtualenv.</p> <p>Once you've run <code>poetry install</code>, if you run <code>poetry run pre-commit install</code> it will install code linting hooks that will run on every commit. This helps ensure code quality.</p> <p>To run tests run <code>poetry run pytest</code> or <code>./run_tests.sh</code> (the latter will generate a coverage report).</p> <p>To release, run <code>poetry publish --build</code>.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#objects","title":"Objects","text":""},{"location":"api/#votekit.ballot.Ballot","title":"<code>Ballot</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Ballot class, contains ranking and assigned weight</p> <p>Attributes</p> <p><code>id</code> :   optionally assigned ballot id</p> <p><code>ranking</code> :   list of candidate ranking</p> <p><code>weight</code> :   weight assigned to a given a ballot</p> <p><code>voters</code> :   list of voters who cast a given a ballot</p> Source code in <code>src/votekit/ballot.py</code> <pre><code>class Ballot(BaseModel):\n    \"\"\"\n    Ballot class, contains ranking and assigned weight\n\n    **Attributes**\n\n    `id`\n    :   optionally assigned ballot id\n\n    `ranking`\n    :   list of candidate ranking\n\n    `weight`\n    :   weight assigned to a given a ballot\n\n    `voters`\n    :   list of voters who cast a given a ballot\n    \"\"\"\n\n    id: Optional[str] = None\n    ranking: list[set]\n    weight: Fraction\n    voters: Optional[set[str]] = None\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    def __eq__(self, other):\n        # Check type\n        if not isinstance(other, Ballot):\n            return False\n\n        # Check id\n        if self.id is not None:\n            if self.id != other.id:\n                return False\n\n        # Check ranking\n        if self.ranking != other.ranking:\n            return False\n\n        # Check weight\n        if self.weight != other.weight:\n            return False\n\n        # Check voters\n        if self.voters is not None:\n            if self.voters != other.voters:\n                return False\n\n        return True\n\n    def __hash__(self):\n        return hash(str(self.ranking))\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile","title":"<code>PreferenceProfile</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>PreferenceProfile class, contains ballots and and candidates for a     given eleciton</p> <p>Attributes</p> <p><code>ballots</code> :   list of <code>Ballot</code> objects</p> <p><code>candiates</code> :   list of candidates</p> <p>Methods</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>class PreferenceProfile(BaseModel):\n    \"\"\"\n    PreferenceProfile class, contains ballots and and candidates for a\n        given eleciton\n\n    **Attributes**\n\n    `ballots`\n    :   list of `Ballot` objects\n\n    `candiates`\n    :   list of candidates\n\n    **Methods**\n    \"\"\"\n\n    ballots: list[Ballot] = []\n    candidates: Optional[list] = None\n    df: pd.DataFrame = pd.DataFrame()\n\n    @validator(\"candidates\")\n    def cands_must_be_unique(cls, candidates: list) -&gt; list:\n        if not len(set(candidates)) == len(candidates):\n            raise ValueError(\"all candidates must be unique\")\n        return candidates\n\n    def get_ballots(self) -&gt; list[Ballot]:\n        \"\"\"\n        Returns list of ballots\n        \"\"\"\n        return self.ballots\n\n    def get_candidates(self) -&gt; list:\n        \"\"\"\n        Returns list of unique candidates\n        \"\"\"\n        unique_cands: set = set()\n        for ballot in self.ballots:\n            unique_cands.update(*ballot.ranking)\n\n        return list(unique_cands)\n\n    # can also cache\n    def num_ballots(self) -&gt; Fraction:\n        \"\"\"\n        Counts number of ballots based on assigned weight\n\n        Returns:\n            Number of ballots cast\n        \"\"\"\n        num_ballots = Fraction(0)\n        for ballot in self.ballots:\n            num_ballots += ballot.weight\n\n        return num_ballots\n\n    def to_dict(self, standardize: bool) -&gt; dict:\n        \"\"\"\n        Converts ballots to dictionary with rankings (keys) and the\n        corresponding total weights (values)\n\n        Returns:\n            A dictionary with with ranking (keys) and corresponding total \\n\n            weights (values)\n        \"\"\"\n        num_ballots = self.num_ballots()\n        di: dict = {}\n        for ballot in self.ballots:\n            rank_tuple = tuple(next(iter(item)) for item in ballot.ranking)\n            if standardize:\n                weight = ballot.weight / num_ballots\n            else:\n                weight = ballot.weight\n            if rank_tuple not in di.keys():\n                di[rank_tuple] = weight\n            else:\n                di[rank_tuple] += weight\n        return di\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    def to_csv(self, fpath):\n        \"\"\"\n        Saves Preference Profile to CSV\n        Args:\n            fpath (str): path to the saved csv\n        \"\"\"\n        with open(fpath, \"w\", newline=\"\") as csvfile:\n            fieldnames = [\"weight\", \"ranking\"]\n            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n            writer.writeheader()\n            for ballot in self.ballots:\n                writer.writerow({\"weight\": ballot.weight, \"ranking\": ballot.ranking})\n\n    def _create_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Creates DF for display and building plots\n        \"\"\"\n        weights = []\n        ballots = []\n        for ballot in self.ballots:\n            part = []\n            for ranking in ballot.ranking:\n                for cand in ranking:\n                    if len(ranking) &gt; 2:\n                        part.append(f\"{cand} (Tie)\")\n                    else:\n                        part.append(cand)\n            ballots.append(tuple(part))\n            weights.append(int(ballot.weight))\n\n        df = pd.DataFrame({\"Ballots\": ballots, \"Weight\": weights})\n        # df[\"Ballots\"] = df[\"Ballots\"].astype(str).str.ljust(60)\n        df[\"Voter Share\"] = df[\"Weight\"] / df[\"Weight\"].sum()\n        # fill nans with zero for edge cases\n        df[\"Voter Share\"] = df[\"Voter Share\"].fillna(0.0)\n        # df[\"Weight\"] = df[\"Weight\"].astype(str).str.rjust(3)\n        return df.reset_index(drop=True)\n\n    def head(\n        self, n: int, percents: Optional[bool] = False, totals: Optional[bool] = False\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Displays top-n ballots in profile based on weight\n\n        Args:\n            n: Number of ballots to view\n            percents: If True, show voter share for a given ballot\n            totals: If true, show total values for Voter Share and Weight\n\n        Returns:\n            A dataframe with top-n ballots\n        \"\"\"\n        if self.df.empty:\n            self.df = self._create_df()\n\n        df = (\n            self.df.sort_values(by=\"Weight\", ascending=False)\n            .head(n)\n            .reset_index(drop=True)\n        )\n\n        if totals:\n            df = _sum_row(df)\n\n        if not percents:\n            return df.drop(columns=\"Voter Share\")\n\n        return df\n\n    def tail(\n        self, n: int, percents: Optional[bool] = False, totals: Optional[bool] = False\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Displays bottom-n ballots in profile based on weight\n\n        Args:\n            n: Number of ballots to view\n            percents: If True, show voter share for a given ballot\n            totals: If true, show total values for Voter Share and Weight\n\n        Returns:\n            A dataframe with bottom-n ballots\n        \"\"\"\n        if self.df.empty:\n            self.df = self._create_df()\n\n        df = (\n            self.df.sort_values(by=\"Weight\", ascending=True)\n            .head(n)\n            .reset_index(drop=True)\n        )\n        if totals:\n            df = _sum_row(df)\n\n        if not percents:\n            return df.drop(columns=\"Voter Share\")\n\n        return df\n\n    def __str__(self) -&gt; str:\n        # Displays top 15 cast ballots or entire profile\n\n        if self.df.empty:\n            self.df = self._create_df()\n\n        if len(self.df) &lt; 15:\n            return self.head(n=len(self.df)).to_string(index=False, justify=\"justify\")\n\n        return self.head(n=15).to_string(index=False, justify=\"justify\")\n\n    # set repr to print outputs\n    __repr__ = __str__\n\n    def condense_ballots(self):\n        \"\"\"\n        Groups ballots by rankings and updates weights\n        \"\"\"\n        class_vector = []\n        seen_rankings = []\n        for ballot in self.ballots:\n            if ballot.ranking not in seen_rankings:\n                seen_rankings.append(ballot.ranking)\n            class_vector.append(seen_rankings.index(ballot.ranking))\n\n        new_ballot_list = []\n        for i, ranking in enumerate(seen_rankings):\n            total_weight = 0\n            for j in range(len(class_vector)):\n                if class_vector[j] == i:\n                    total_weight += self.ballots[j].weight\n            new_ballot_list.append(\n                Ballot(ranking=ranking, weight=Fraction(total_weight))\n            )\n        self.ballots = new_ballot_list\n\n    def __eq__(self, other):\n        if not isinstance(other, PreferenceProfile):\n            return False\n        self.condense_ballots()\n        other.condense_ballots()\n        for b in self.ballots:\n            if b not in other.ballots:\n                return False\n        for b in self.ballots:\n            if b not in other.ballots:\n                return False\n        return True\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.condense_ballots","title":"<code>condense_ballots()</code>","text":"<p>Groups ballots by rankings and updates weights</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def condense_ballots(self):\n    \"\"\"\n    Groups ballots by rankings and updates weights\n    \"\"\"\n    class_vector = []\n    seen_rankings = []\n    for ballot in self.ballots:\n        if ballot.ranking not in seen_rankings:\n            seen_rankings.append(ballot.ranking)\n        class_vector.append(seen_rankings.index(ballot.ranking))\n\n    new_ballot_list = []\n    for i, ranking in enumerate(seen_rankings):\n        total_weight = 0\n        for j in range(len(class_vector)):\n            if class_vector[j] == i:\n                total_weight += self.ballots[j].weight\n        new_ballot_list.append(\n            Ballot(ranking=ranking, weight=Fraction(total_weight))\n        )\n    self.ballots = new_ballot_list\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.get_ballots","title":"<code>get_ballots()</code>","text":"<p>Returns list of ballots</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def get_ballots(self) -&gt; list[Ballot]:\n    \"\"\"\n    Returns list of ballots\n    \"\"\"\n    return self.ballots\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.get_candidates","title":"<code>get_candidates()</code>","text":"<p>Returns list of unique candidates</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def get_candidates(self) -&gt; list:\n    \"\"\"\n    Returns list of unique candidates\n    \"\"\"\n    unique_cands: set = set()\n    for ballot in self.ballots:\n        unique_cands.update(*ballot.ranking)\n\n    return list(unique_cands)\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.head","title":"<code>head(n, percents=False, totals=False)</code>","text":"<p>Displays top-n ballots in profile based on weight</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of ballots to view</p> required <code>percents</code> <code>Optional[bool]</code> <p>If True, show voter share for a given ballot</p> <code>False</code> <code>totals</code> <code>Optional[bool]</code> <p>If true, show total values for Voter Share and Weight</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe with top-n ballots</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def head(\n    self, n: int, percents: Optional[bool] = False, totals: Optional[bool] = False\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Displays top-n ballots in profile based on weight\n\n    Args:\n        n: Number of ballots to view\n        percents: If True, show voter share for a given ballot\n        totals: If true, show total values for Voter Share and Weight\n\n    Returns:\n        A dataframe with top-n ballots\n    \"\"\"\n    if self.df.empty:\n        self.df = self._create_df()\n\n    df = (\n        self.df.sort_values(by=\"Weight\", ascending=False)\n        .head(n)\n        .reset_index(drop=True)\n    )\n\n    if totals:\n        df = _sum_row(df)\n\n    if not percents:\n        return df.drop(columns=\"Voter Share\")\n\n    return df\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.num_ballots","title":"<code>num_ballots()</code>","text":"<p>Counts number of ballots based on assigned weight</p> <p>Returns:</p> Type Description <code>Fraction</code> <p>Number of ballots cast</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def num_ballots(self) -&gt; Fraction:\n    \"\"\"\n    Counts number of ballots based on assigned weight\n\n    Returns:\n        Number of ballots cast\n    \"\"\"\n    num_ballots = Fraction(0)\n    for ballot in self.ballots:\n        num_ballots += ballot.weight\n\n    return num_ballots\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.tail","title":"<code>tail(n, percents=False, totals=False)</code>","text":"<p>Displays bottom-n ballots in profile based on weight</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of ballots to view</p> required <code>percents</code> <code>Optional[bool]</code> <p>If True, show voter share for a given ballot</p> <code>False</code> <code>totals</code> <code>Optional[bool]</code> <p>If true, show total values for Voter Share and Weight</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe with bottom-n ballots</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def tail(\n    self, n: int, percents: Optional[bool] = False, totals: Optional[bool] = False\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Displays bottom-n ballots in profile based on weight\n\n    Args:\n        n: Number of ballots to view\n        percents: If True, show voter share for a given ballot\n        totals: If true, show total values for Voter Share and Weight\n\n    Returns:\n        A dataframe with bottom-n ballots\n    \"\"\"\n    if self.df.empty:\n        self.df = self._create_df()\n\n    df = (\n        self.df.sort_values(by=\"Weight\", ascending=True)\n        .head(n)\n        .reset_index(drop=True)\n    )\n    if totals:\n        df = _sum_row(df)\n\n    if not percents:\n        return df.drop(columns=\"Voter Share\")\n\n    return df\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.to_csv","title":"<code>to_csv(fpath)</code>","text":"<p>Saves Preference Profile to CSV Args:     fpath (str): path to the saved csv</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def to_csv(self, fpath):\n    \"\"\"\n    Saves Preference Profile to CSV\n    Args:\n        fpath (str): path to the saved csv\n    \"\"\"\n    with open(fpath, \"w\", newline=\"\") as csvfile:\n        fieldnames = [\"weight\", \"ranking\"]\n        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n        writer.writeheader()\n        for ballot in self.ballots:\n            writer.writerow({\"weight\": ballot.weight, \"ranking\": ballot.ranking})\n</code></pre>"},{"location":"api/#votekit.pref_profile.PreferenceProfile.to_dict","title":"<code>to_dict(standardize)</code>","text":"<p>Converts ballots to dictionary with rankings (keys) and the corresponding total weights (values)</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary with with ranking (keys) and corresponding total </p> <code>dict</code> <p>weights (values)</p> Source code in <code>src/votekit/pref_profile.py</code> <pre><code>def to_dict(self, standardize: bool) -&gt; dict:\n    \"\"\"\n    Converts ballots to dictionary with rankings (keys) and the\n    corresponding total weights (values)\n\n    Returns:\n        A dictionary with with ranking (keys) and corresponding total \\n\n        weights (values)\n    \"\"\"\n    num_ballots = self.num_ballots()\n    di: dict = {}\n    for ballot in self.ballots:\n        rank_tuple = tuple(next(iter(item)) for item in ballot.ranking)\n        if standardize:\n            weight = ballot.weight / num_ballots\n        else:\n            weight = ballot.weight\n        if rank_tuple not in di.keys():\n            di[rank_tuple] = weight\n        else:\n            di[rank_tuple] += weight\n    return di\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState","title":"<code>ElectionState</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Class for storing information on each round of a RCV election and the final outcome.</p> <p>Attributes <code>curr_round</code> :   current round number. Defaults to 0</p> <p><code>elected</code> :   list of candidates who pass a threshold to win</p> <p><code>eliminated</code> :   list of candidates who were eliminated</p> <p><code>remaining</code> :   list of candidates who are still in the running</p> <p><code>rankings</code> :   list ranking of candidates with sets representing ties</p> <p><code>profile</code> :   an instance of a preference profile object</p> <p><code>previous</code> :   an instance of ElectionState representing potential previous round</p> <p>Methods</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>class ElectionState(BaseModel):\n    \"\"\"\n    Class for storing information on each round of a RCV election and the final outcome.\n\n    **Attributes**\n    `curr_round`\n    :   current round number. Defaults to 0\n\n    `elected`\n    :   list of candidates who pass a threshold to win\n\n\n    `eliminated`\n    :   list of candidates who were eliminated\n\n    `remaining`\n    :   list of candidates who are still in the running\n\n    `rankings`\n    :   list ranking of candidates with sets representing ties\n\n    `profile`\n    :   an instance of a preference profile object\n\n    `previous`\n    :   an instance of ElectionState representing potential previous round\n\n    **Methods**\n    \"\"\"\n\n    curr_round: int = 0\n    elected: list[set[str]] = []\n    eliminated: list[set[str]] = []\n    remaining: list[set[str]] = []\n    profile: PreferenceProfile\n    previous: Optional[\"ElectionState\"] = None\n\n    class Config:\n        allow_mutation = False\n\n    def get_all_winners(self) -&gt; list[set[str]]:\n        \"\"\"\n        Returns a list of elected candidates ordered from first round to current round\n        \"\"\"\n        if self.previous:\n            return self.previous.get_all_winners() + self.elected\n        else:\n            return self.elected\n\n    def get_all_eliminated(self) -&gt; list[set[str]]:\n        \"\"\"\n        Returns a list of eliminated candidates ordered from current round to first round\n        \"\"\"\n        if self.previous:\n            return self.eliminated + self.previous.get_all_eliminated()\n        else:\n            return self.eliminated\n\n    def get_rankings(self) -&gt; list[set[str]]:\n        \"\"\"\n        Returns list of all candidates in order of their ranking after each round\n        \"\"\"\n        if self.remaining != [{}]:\n            return self.get_all_winners() + self.remaining + self.get_all_eliminated()\n        else:\n            return self.get_all_winners() + self.get_all_eliminated()\n\n    def get_round_outcome(self, roundNum: int) -&gt; dict:\n        # {'elected':list[set[str]], 'eliminated':list[set[str]]}\n        \"\"\"\n        Returns a dictionary with elected and eliminated candidates\n        \"\"\"\n        if self.curr_round == roundNum:\n            return {\n                \"Elected\": [c for s in self.elected for c in s],\n                \"Eliminated\": [c for s in self.eliminated for c in s],\n            }\n        elif self.previous:\n            return self.previous.get_round_outcome(roundNum)\n        else:\n            raise ValueError(\"Round number out of range\")\n\n    def changed_rankings(self) -&gt; dict:\n        \"\"\"\n        Returns dict of (key) candidate(s) who changed\n        ranking from previous round and (value) a tuple of (previous rank, new rank)\n        \"\"\"\n\n        if not self.previous:\n            raise ValueError(\"This is the first round, cannot compare previous ranking\")\n\n        prev_ranking: dict = candidate_position_dict(self.previous.get_rankings())\n        curr_ranking: dict = candidate_position_dict(self.get_rankings())\n        if curr_ranking == prev_ranking:\n            return {}\n\n        changes = {}\n        for candidate, index in curr_ranking.items():\n            if prev_ranking[candidate] != index:\n                changes[candidate] = (prev_ranking[candidate], index)\n        return changes\n\n    def status(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Returns dataframe displaying candidate, status (elected, eliminated,\n        remaining), and the round their status updated\n        \"\"\"\n        all_cands = [c for s in self.get_rankings() for c in s]\n        status_df = pd.DataFrame(\n            {\n                \"Candidate\": all_cands,\n                \"Status\": [\"Remaining\"] * len(all_cands),\n                \"Round\": [self.curr_round] * len(all_cands),\n            }\n        )\n\n        for round in range(1, self.curr_round + 1):\n            results = self.get_round_outcome(round)\n            for status, candidates in results.items():\n                for cand in candidates:\n                    status_df.loc[status_df[\"Candidate\"] == cand, \"Status\"] = status\n                    status_df.loc[status_df[\"Candidate\"] == cand, \"Round\"] = round\n\n        return status_df\n\n    def __str__(self):\n        show = self.status()\n        return show.to_string(index=False, justify=\"justify\")\n\n    __repr__ = __str__\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.changed_rankings","title":"<code>changed_rankings()</code>","text":"<p>Returns dict of (key) candidate(s) who changed ranking from previous round and (value) a tuple of (previous rank, new rank)</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>def changed_rankings(self) -&gt; dict:\n    \"\"\"\n    Returns dict of (key) candidate(s) who changed\n    ranking from previous round and (value) a tuple of (previous rank, new rank)\n    \"\"\"\n\n    if not self.previous:\n        raise ValueError(\"This is the first round, cannot compare previous ranking\")\n\n    prev_ranking: dict = candidate_position_dict(self.previous.get_rankings())\n    curr_ranking: dict = candidate_position_dict(self.get_rankings())\n    if curr_ranking == prev_ranking:\n        return {}\n\n    changes = {}\n    for candidate, index in curr_ranking.items():\n        if prev_ranking[candidate] != index:\n            changes[candidate] = (prev_ranking[candidate], index)\n    return changes\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.get_all_eliminated","title":"<code>get_all_eliminated()</code>","text":"<p>Returns a list of eliminated candidates ordered from current round to first round</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>def get_all_eliminated(self) -&gt; list[set[str]]:\n    \"\"\"\n    Returns a list of eliminated candidates ordered from current round to first round\n    \"\"\"\n    if self.previous:\n        return self.eliminated + self.previous.get_all_eliminated()\n    else:\n        return self.eliminated\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.get_all_winners","title":"<code>get_all_winners()</code>","text":"<p>Returns a list of elected candidates ordered from first round to current round</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>def get_all_winners(self) -&gt; list[set[str]]:\n    \"\"\"\n    Returns a list of elected candidates ordered from first round to current round\n    \"\"\"\n    if self.previous:\n        return self.previous.get_all_winners() + self.elected\n    else:\n        return self.elected\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.get_rankings","title":"<code>get_rankings()</code>","text":"<p>Returns list of all candidates in order of their ranking after each round</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>def get_rankings(self) -&gt; list[set[str]]:\n    \"\"\"\n    Returns list of all candidates in order of their ranking after each round\n    \"\"\"\n    if self.remaining != [{}]:\n        return self.get_all_winners() + self.remaining + self.get_all_eliminated()\n    else:\n        return self.get_all_winners() + self.get_all_eliminated()\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.get_round_outcome","title":"<code>get_round_outcome(roundNum)</code>","text":"<p>Returns a dictionary with elected and eliminated candidates</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>def get_round_outcome(self, roundNum: int) -&gt; dict:\n    # {'elected':list[set[str]], 'eliminated':list[set[str]]}\n    \"\"\"\n    Returns a dictionary with elected and eliminated candidates\n    \"\"\"\n    if self.curr_round == roundNum:\n        return {\n            \"Elected\": [c for s in self.elected for c in s],\n            \"Eliminated\": [c for s in self.eliminated for c in s],\n        }\n    elif self.previous:\n        return self.previous.get_round_outcome(roundNum)\n    else:\n        raise ValueError(\"Round number out of range\")\n</code></pre>"},{"location":"api/#votekit.election_state.ElectionState.status","title":"<code>status()</code>","text":"<p>Returns dataframe displaying candidate, status (elected, eliminated, remaining), and the round their status updated</p> Source code in <code>src/votekit/election_state.py</code> <pre><code>def status(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Returns dataframe displaying candidate, status (elected, eliminated,\n    remaining), and the round their status updated\n    \"\"\"\n    all_cands = [c for s in self.get_rankings() for c in s]\n    status_df = pd.DataFrame(\n        {\n            \"Candidate\": all_cands,\n            \"Status\": [\"Remaining\"] * len(all_cands),\n            \"Round\": [self.curr_round] * len(all_cands),\n        }\n    )\n\n    for round in range(1, self.curr_round + 1):\n        results = self.get_round_outcome(round)\n        for status, candidates in results.items():\n            for cand in candidates:\n                status_df.loc[status_df[\"Candidate\"] == cand, \"Status\"] = status\n                status_df.loc[status_df[\"Candidate\"] == cand, \"Round\"] = round\n\n    return status_df\n</code></pre>"},{"location":"api/#votekit.graphs.ballot_graph.BallotGraph","title":"<code>BallotGraph</code>","text":"<p>             Bases: <code>Graph</code></p> <p>Class to build ballot graphs.</p> <p>Attributes</p> <p><code>source</code> :   data to create graph from, either PreferenceProfile object, number of         candidates, or list of candidates</p> <p><code>allow_partial</code> :   if True, builds graph using all possible ballots,     if False, only uses total linear ordered ballots     if building from a PreferenceProfile, defaults to True</p> <p><code>fix_short</code> : if True, auto completes ballots of length n-1 to n.</p> <p>Methods</p> Source code in <code>src/votekit/graphs/ballot_graph.py</code> <pre><code>class BallotGraph(Graph):\n    \"\"\"\n    Class to build ballot graphs.\n\n    **Attributes**\n\n    `source`\n    :   data to create graph from, either PreferenceProfile object, number of\n            candidates, or list of candidates\n\n    `allow_partial`\n    :   if True, builds graph using all possible ballots,\n        if False, only uses total linear ordered ballots\n        if building from a PreferenceProfile, defaults to True\n\n    `fix_short`\n    : if True, auto completes ballots of length n-1 to n.\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        source: Union[PreferenceProfile, int, list],\n        allow_partial: Optional[bool] = True,\n        fix_short: Optional[bool] = True\n    ):\n        super().__init__()\n\n        self.profile = None\n        self.candidates = None\n        self.allow_partial = allow_partial\n\n        if isinstance(source, int):\n            self.num_cands = source\n            self.graph = self.build_graph(source)\n\n        if isinstance(source, list):\n            self.num_cands = len(source)\n            self.graph = self.build_graph(len(source))\n            self.candidates = source\n\n        if isinstance(source, PreferenceProfile):\n            self.profile = source\n            self.num_voters = source.num_ballots()\n            self.num_cands = len(source.get_candidates())\n            self.allow_partial = True\n            if not self.graph:\n                self.graph = self.build_graph(len(source.get_candidates()))\n            self.graph = self.from_profile(source, fix_short = fix_short)\n\n        self.num_voters = sum(self.node_weights.values())\n\n        # if no partial ballots allowed, create induced subgraph\n        if not self.allow_partial:\n            total_ballots = [n for n in self.graph.nodes() if len(n) == self.num_cands]\n            self.graph = self.graph.subgraph(total_ballots)\n\n        if not self.node_weights:\n            self.node_weights = {ballot: 0 for ballot in self.graph.nodes}\n\n    def _relabel(self, gr: nx.Graph, new_label: int, num_cands: int) -&gt; nx.Graph:\n        \"\"\"\n        Relabels nodes in gr based on new_label\n        \"\"\"\n        node_map = {}\n        graph_nodes = list(gr.nodes)\n\n        for k in graph_nodes:\n            # add the value of new_label to every entry in every ballot\n            tmp = [new_label + y for y in k]\n\n            # reduce everything mod new_label\n            for i in range(len(tmp)):\n                if tmp[i] &gt; num_cands:\n                    tmp[i] = tmp[i] - num_cands\n            node_map[k] = tuple([new_label] + tmp)\n\n        return nx.relabel_nodes(gr, node_map)\n\n    def build_graph(self, n: int) -&gt; nx.Graph:  # ask Gabe about optimizing?\n        \"\"\"\n        Builds graph of all possible ballots given a number of candiates\n\n        Args:\n            n: number of candidates per an election\n        \"\"\"\n        Gc = nx.Graph()\n        # base cases\n        if n == 1:\n            Gc.add_nodes_from([(1)], weight=0, cast=False)\n\n        elif n == 2:\n            Gc.add_nodes_from([(1, 2), (2, 1)], weight=0, cast=False)\n            Gc.add_edges_from([((1, 2), (2, 1))])\n\n        elif n &gt; 2:\n            G_prev = self.build_graph(n - 1)\n            for i in range(1, n + 1):\n                # add the node for the bullet vote i\n                Gc.add_node((i,), weight=0, cast=False)\n\n                # make the subgraph for the ballots where i is ranked first\n                G_corner = self._relabel(G_prev, i, n)\n\n                # add the components from that graph to the larger graph\n                Gc.add_nodes_from(G_corner.nodes, weight=0, cast=False)\n                Gc.add_edges_from(G_corner.edges)\n\n                # connect the bullet vote node to the appropriate vertices\n                if n == 3:\n                    Gc.add_edges_from([(k, (i,)) for k in G_corner.nodes])\n                else:\n                    Gc.add_edges_from(\n                        [(k, (i,)) for k in G_corner.nodes if len(k) == 2]\n                    )\n\n            nodes = Gc.nodes\n\n            new_edges = [\n                (bal, (bal[1], bal[0]) + bal[2:]) for bal in nodes if len(bal) &gt;= 2\n            ]\n            Gc.add_edges_from(new_edges)\n\n        return Gc\n\n    def from_profile(\n        self, profile: PreferenceProfile,\n        fix_short: Optional[bool] = True\n    ) -&gt; nx.Graph:\n        \"\"\"\n        Updates existing graph based on cast ballots from a PreferenceProfile,\n        or creates graph based on PreferenceProfile\n\n        Args:\n            profile: PreferenceProfile assigned to graph\n\n\n        Returns:\n            Graph based on PreferenceProfile, 'cast' node attribute indicates\n                    ballots cast in PreferenceProfile\n        \"\"\"\n        if not self.profile:\n            self.profile = profile\n\n        if not self.num_voters:\n            self.num_voters = profile.num_ballots()\n\n        self.candidates = profile.get_candidates()\n        ballots = profile.get_ballots()\n        self.cand_num = self._number_cands(tuple(self.candidates))\n        self.node_weights = {ballot: 0 for ballot in self.graph.nodes}\n\n        for ballot in ballots:\n            ballot_node = []\n            for position in ballot.ranking:\n                if len(position) &gt; 1:\n                    raise ValueError(\n                        \"ballots must be cleaned to resolve ties\"\n                    )  # still unsure about ties\n                for cand in position:\n                    ballot_node.append(self.cand_num[cand])\n            if len(ballot_node) == len(self.candidates) - 1 and fix_short:\n                ballot_node = self.fix_short_ballot(\n                    ballot_node, list(self.cand_num.values())\n                )\n\n            if tuple(ballot_node) in self.graph.nodes:\n                self.graph.nodes[tuple(ballot_node)][\"weight\"] += ballot.weight\n                self.graph.nodes[tuple(ballot_node)][\"cast\"] = True\n                self.node_weights[tuple(ballot_node)] += ballot.weight\n\n        return self.graph\n\n    def fix_short_ballot(self, ballot: list, candidates: list) -&gt; list:\n        \"\"\"\n        Appends short ballots of n-1 length to add to BallotGraph\n        \"\"\"\n        missing = set(candidates).difference(set(ballot))\n\n        return ballot + list(missing)\n\n    def label_cands(self, candidates,\n                    to_display: Callable = all_nodes):\n        \"\"\"\n        Assigns candidate labels to ballot graph for plotting\n\n        Args:\n            to_display: a Boolean callable that takes in a graph and node \n                        returns True if node  should be displayed\n        \"\"\"\n\n        candidate_numbers = self._number_cands(tuple(candidates))\n\n        cand_dict = {value: key for key, value in candidate_numbers.items()}\n\n        cand_labels = {}\n        for node in self.graph.nodes:\n            if to_display(self.graph, node):\n                ballot = []\n                for num in node:\n                    ballot.append(cand_dict[num])\n\n                # label the ballot and give the number of votes\n                cand_labels[node] = str(tuple(ballot))+\": \" + \\\n                                str(self.graph.nodes[node][\"weight\"])\n\n        return cand_labels\n\n    @cache\n    def _number_cands(self, cands: tuple) -&gt; dict:\n        \"\"\"\n        Assigns numerical marker to candidates\n        \"\"\"\n        legend = {}\n        for idx, cand in enumerate(cands):\n            legend[cand] = idx + 1\n\n        return legend\n\n    def draw(self, to_display: Callable = all_nodes,\n             neighborhoods: Optional[list[tuple]] = [],\n             show_cast: Optional[bool] = False,\n             labels: Optional[bool] = False):\n        \"\"\"\n        Visualize the graph.\n\n        Args:\n            to_display: a boolean function that takes graph and node as input, returns True if you\n                        want that node displayed. Defaults to showing all nodes.\n            neighborhoods: a list of neighborhoods to display, given as tuple (node, radius).\n                            (n,1) gives all nodes within one step of n.\n            show_cast: If True, show only nodes with \"cast\" attribute = True.\n                        If False, show all nodes.\n            labels: If True, labels nodes with candidate names and vote totals\n        \"\"\"\n\n\n        def cast_nodes(graph, node):\n            return graph.nodes[node][\"cast\"]\n\n        def in_neighborhoods(graph, node):\n            centers = [node for node, radius in neighborhoods]\n            radii = [radius for node, radius in neighborhoods]\n\n            distances = [nx.shortest_path_length(graph, node, x) for x in centers]\n\n            return (True in [d &lt;= r for d,r in zip(distances, radii)])\n\n        if show_cast:\n            to_display = cast_nodes\n\n        if neighborhoods:\n            to_display = in_neighborhoods\n\n        ballots = [n for n in self.graph.nodes if to_display(self.graph, n)]\n\n        node_labels = None\n        if labels:\n            if not self.candidates:\n                raise ValueError(\"no candidate names assigned\")\n            node_labels = self.label_cands(self.candidates, to_display)\n\n        subgraph = self.graph.subgraph(ballots)\n\n        pos = nx.spring_layout(subgraph)\n        nx.draw_networkx(subgraph, pos = pos, \n                         with_labels=True, labels=node_labels)\n\n        # handles labels overlapping with margins\n        x_values, y_values = zip(*pos.values())\n        x_max, y_max = max(x_values), max(y_values)\n        x_min, y_min = min(x_values), min(y_values)\n        x_margin = (x_max - x_min) * 0.25\n        y_margin = (y_max - y_min) * 0.25\n        plt.xlim(x_min - x_margin, x_max + x_margin)\n        plt.ylim(y_min - y_margin, y_max + y_margin)\n        plt.show()\n</code></pre>"},{"location":"api/#votekit.graphs.ballot_graph.BallotGraph.build_graph","title":"<code>build_graph(n)</code>","text":"<p>Builds graph of all possible ballots given a number of candiates</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>number of candidates per an election</p> required Source code in <code>src/votekit/graphs/ballot_graph.py</code> <pre><code>def build_graph(self, n: int) -&gt; nx.Graph:  # ask Gabe about optimizing?\n    \"\"\"\n    Builds graph of all possible ballots given a number of candiates\n\n    Args:\n        n: number of candidates per an election\n    \"\"\"\n    Gc = nx.Graph()\n    # base cases\n    if n == 1:\n        Gc.add_nodes_from([(1)], weight=0, cast=False)\n\n    elif n == 2:\n        Gc.add_nodes_from([(1, 2), (2, 1)], weight=0, cast=False)\n        Gc.add_edges_from([((1, 2), (2, 1))])\n\n    elif n &gt; 2:\n        G_prev = self.build_graph(n - 1)\n        for i in range(1, n + 1):\n            # add the node for the bullet vote i\n            Gc.add_node((i,), weight=0, cast=False)\n\n            # make the subgraph for the ballots where i is ranked first\n            G_corner = self._relabel(G_prev, i, n)\n\n            # add the components from that graph to the larger graph\n            Gc.add_nodes_from(G_corner.nodes, weight=0, cast=False)\n            Gc.add_edges_from(G_corner.edges)\n\n            # connect the bullet vote node to the appropriate vertices\n            if n == 3:\n                Gc.add_edges_from([(k, (i,)) for k in G_corner.nodes])\n            else:\n                Gc.add_edges_from(\n                    [(k, (i,)) for k in G_corner.nodes if len(k) == 2]\n                )\n\n        nodes = Gc.nodes\n\n        new_edges = [\n            (bal, (bal[1], bal[0]) + bal[2:]) for bal in nodes if len(bal) &gt;= 2\n        ]\n        Gc.add_edges_from(new_edges)\n\n    return Gc\n</code></pre>"},{"location":"api/#votekit.graphs.ballot_graph.BallotGraph.draw","title":"<code>draw(to_display=all_nodes, neighborhoods=[], show_cast=False, labels=False)</code>","text":"<p>Visualize the graph.</p> <p>Parameters:</p> Name Type Description Default <code>to_display</code> <code>Callable</code> <p>a boolean function that takes graph and node as input, returns True if you         want that node displayed. Defaults to showing all nodes.</p> <code>all_nodes</code> <code>neighborhoods</code> <code>Optional[list[tuple]]</code> <p>a list of neighborhoods to display, given as tuple (node, radius).             (n,1) gives all nodes within one step of n.</p> <code>[]</code> <code>show_cast</code> <code>Optional[bool]</code> <p>If True, show only nodes with \"cast\" attribute = True.         If False, show all nodes.</p> <code>False</code> <code>labels</code> <code>Optional[bool]</code> <p>If True, labels nodes with candidate names and vote totals</p> <code>False</code> Source code in <code>src/votekit/graphs/ballot_graph.py</code> <pre><code>def draw(self, to_display: Callable = all_nodes,\n         neighborhoods: Optional[list[tuple]] = [],\n         show_cast: Optional[bool] = False,\n         labels: Optional[bool] = False):\n    \"\"\"\n    Visualize the graph.\n\n    Args:\n        to_display: a boolean function that takes graph and node as input, returns True if you\n                    want that node displayed. Defaults to showing all nodes.\n        neighborhoods: a list of neighborhoods to display, given as tuple (node, radius).\n                        (n,1) gives all nodes within one step of n.\n        show_cast: If True, show only nodes with \"cast\" attribute = True.\n                    If False, show all nodes.\n        labels: If True, labels nodes with candidate names and vote totals\n    \"\"\"\n\n\n    def cast_nodes(graph, node):\n        return graph.nodes[node][\"cast\"]\n\n    def in_neighborhoods(graph, node):\n        centers = [node for node, radius in neighborhoods]\n        radii = [radius for node, radius in neighborhoods]\n\n        distances = [nx.shortest_path_length(graph, node, x) for x in centers]\n\n        return (True in [d &lt;= r for d,r in zip(distances, radii)])\n\n    if show_cast:\n        to_display = cast_nodes\n\n    if neighborhoods:\n        to_display = in_neighborhoods\n\n    ballots = [n for n in self.graph.nodes if to_display(self.graph, n)]\n\n    node_labels = None\n    if labels:\n        if not self.candidates:\n            raise ValueError(\"no candidate names assigned\")\n        node_labels = self.label_cands(self.candidates, to_display)\n\n    subgraph = self.graph.subgraph(ballots)\n\n    pos = nx.spring_layout(subgraph)\n    nx.draw_networkx(subgraph, pos = pos, \n                     with_labels=True, labels=node_labels)\n\n    # handles labels overlapping with margins\n    x_values, y_values = zip(*pos.values())\n    x_max, y_max = max(x_values), max(y_values)\n    x_min, y_min = min(x_values), min(y_values)\n    x_margin = (x_max - x_min) * 0.25\n    y_margin = (y_max - y_min) * 0.25\n    plt.xlim(x_min - x_margin, x_max + x_margin)\n    plt.ylim(y_min - y_margin, y_max + y_margin)\n    plt.show()\n</code></pre>"},{"location":"api/#votekit.graphs.ballot_graph.BallotGraph.fix_short_ballot","title":"<code>fix_short_ballot(ballot, candidates)</code>","text":"<p>Appends short ballots of n-1 length to add to BallotGraph</p> Source code in <code>src/votekit/graphs/ballot_graph.py</code> <pre><code>def fix_short_ballot(self, ballot: list, candidates: list) -&gt; list:\n    \"\"\"\n    Appends short ballots of n-1 length to add to BallotGraph\n    \"\"\"\n    missing = set(candidates).difference(set(ballot))\n\n    return ballot + list(missing)\n</code></pre>"},{"location":"api/#votekit.graphs.ballot_graph.BallotGraph.from_profile","title":"<code>from_profile(profile, fix_short=True)</code>","text":"<p>Updates existing graph based on cast ballots from a PreferenceProfile, or creates graph based on PreferenceProfile</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>PreferenceProfile</code> <p>PreferenceProfile assigned to graph</p> required <p>Returns:</p> Type Description <code>Graph</code> <p>Graph based on PreferenceProfile, 'cast' node attribute indicates     ballots cast in PreferenceProfile</p> Source code in <code>src/votekit/graphs/ballot_graph.py</code> <pre><code>def from_profile(\n    self, profile: PreferenceProfile,\n    fix_short: Optional[bool] = True\n) -&gt; nx.Graph:\n    \"\"\"\n    Updates existing graph based on cast ballots from a PreferenceProfile,\n    or creates graph based on PreferenceProfile\n\n    Args:\n        profile: PreferenceProfile assigned to graph\n\n\n    Returns:\n        Graph based on PreferenceProfile, 'cast' node attribute indicates\n                ballots cast in PreferenceProfile\n    \"\"\"\n    if not self.profile:\n        self.profile = profile\n\n    if not self.num_voters:\n        self.num_voters = profile.num_ballots()\n\n    self.candidates = profile.get_candidates()\n    ballots = profile.get_ballots()\n    self.cand_num = self._number_cands(tuple(self.candidates))\n    self.node_weights = {ballot: 0 for ballot in self.graph.nodes}\n\n    for ballot in ballots:\n        ballot_node = []\n        for position in ballot.ranking:\n            if len(position) &gt; 1:\n                raise ValueError(\n                    \"ballots must be cleaned to resolve ties\"\n                )  # still unsure about ties\n            for cand in position:\n                ballot_node.append(self.cand_num[cand])\n        if len(ballot_node) == len(self.candidates) - 1 and fix_short:\n            ballot_node = self.fix_short_ballot(\n                ballot_node, list(self.cand_num.values())\n            )\n\n        if tuple(ballot_node) in self.graph.nodes:\n            self.graph.nodes[tuple(ballot_node)][\"weight\"] += ballot.weight\n            self.graph.nodes[tuple(ballot_node)][\"cast\"] = True\n            self.node_weights[tuple(ballot_node)] += ballot.weight\n\n    return self.graph\n</code></pre>"},{"location":"api/#votekit.graphs.ballot_graph.BallotGraph.label_cands","title":"<code>label_cands(candidates, to_display=all_nodes)</code>","text":"<p>Assigns candidate labels to ballot graph for plotting</p> <p>Parameters:</p> Name Type Description Default <code>to_display</code> <code>Callable</code> <p>a Boolean callable that takes in a graph and node          returns True if node  should be displayed</p> <code>all_nodes</code> Source code in <code>src/votekit/graphs/ballot_graph.py</code> <pre><code>def label_cands(self, candidates,\n                to_display: Callable = all_nodes):\n    \"\"\"\n    Assigns candidate labels to ballot graph for plotting\n\n    Args:\n        to_display: a Boolean callable that takes in a graph and node \n                    returns True if node  should be displayed\n    \"\"\"\n\n    candidate_numbers = self._number_cands(tuple(candidates))\n\n    cand_dict = {value: key for key, value in candidate_numbers.items()}\n\n    cand_labels = {}\n    for node in self.graph.nodes:\n        if to_display(self.graph, node):\n            ballot = []\n            for num in node:\n                ballot.append(cand_dict[num])\n\n            # label the ballot and give the number of votes\n            cand_labels[node] = str(tuple(ballot))+\": \" + \\\n                            str(self.graph.nodes[node][\"weight\"])\n\n    return cand_labels\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph","title":"<code>PairwiseComparisonGraph</code>","text":"<p>             Bases: <code>Graph</code></p> <p>Class to constructe Pairwise Comparison graph where nodes are candidates and edges are pairwise preferences</p> <p>Attributes</p> <p><code>profile</code> :   profile to construction graph from</p> <p><code>ballot_length</code> :   (Optional) max length of ballot, if None longest possible ballot </p> <pre><code>lenth is assigned\n</code></pre> <p>Methods</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>class PairwiseComparisonGraph(Graph):\n    \"\"\"\n    Class to constructe Pairwise Comparison graph where nodes are candidates\n    and edges are pairwise preferences\n\n    **Attributes**\n\n    `profile`\n    :   profile to construction graph from\n\n    `ballot_length`\n    :   (Optional) max length of ballot, if None longest possible ballot \\n\n        lenth is assigned\n\n    **Methods**\n    \"\"\"\n\n    def __init__(self, profile: PreferenceProfile, ballot_length=None):\n        self.ballot_length = ballot_length\n        if ballot_length is None:\n            self.ballot_length = len(profile.get_candidates())\n        full_profile = self.ballot_fill(profile, self.ballot_length)\n        self.profile = full_profile\n        self.candidates = self.profile.get_candidates()\n        self.pairwise_dict = self.compute_pairwise_dict()\n        self.pairwise_graph = self.build_graph()\n\n    def ballot_fill(self, profile: PreferenceProfile, ballot_length: int):\n        \"\"\"\n        Fills incomplete ballots for pairwise comparison\n        \"\"\"\n        cand_list = [{cand} for cand in profile.get_candidates()]\n        updated_ballot_list = []\n\n        for ballot in profile.get_ballots():\n            if len(ballot.ranking) &lt; ballot_length:\n                missing_cands = [\n                    cand for cand in cand_list if cand not in ballot.ranking\n                ]\n                missing_cands_perms = list(\n                    permutations(missing_cands, len(missing_cands))\n                )\n                frac_freq = ballot.weight / (len(missing_cands_perms))\n                for perm in missing_cands_perms:\n                    updated_rank = ballot.ranking + list(perm)\n                    updated_ballot = Ballot(\n                        ranking=updated_rank, weight=Fraction(frac_freq, 1)\n                    )\n                    updated_ballot_list.append(updated_ballot)\n            else:\n                updated_ballot_list.append(ballot)\n        return PreferenceProfile(ballots=updated_ballot_list)\n\n    # Helper functions to make pairwise comparison graph\n    def head2head_count(self, cand1, cand2) -&gt; Fraction:\n        \"\"\"\n        Counts head to head comparisons between two candidates\n        \"\"\"\n        count = 0\n        ballots_list = self.profile.get_ballots()\n        for ballot in ballots_list:\n            rank_list = ballot.ranking\n            for s in rank_list:\n                if cand1 in s:\n                    count += ballot.weight\n                    break\n                elif cand2 in s:\n                    break\n        return Fraction(count)\n\n    def compute_pairwise_dict(self) -&gt; dict:\n        \"\"\"\n        Constructs dictionary where keys are tuples (cand_a, cand_b) containing\n        two candidates and values is the frequency cand_a is preferred to\n        cand_b\n        \"\"\"\n        pairwise_dict = {}  # {(cand_a, cand_b): freq cand_a is preferred over cand_b}\n        cand_pairs = combinations(self.candidates, 2)\n\n        for pair in cand_pairs:\n            cand_a, cand_b = pair[0], pair[1]\n            head_2_head_dict = {\n                (cand_a, cand_b): self.head2head_count(cand_a, cand_b),\n                (cand_b, cand_a): self.head2head_count(cand_b, cand_a),\n            }\n            max_pair = max(zip(head_2_head_dict.values(), head_2_head_dict.keys()))\n            pairwise_dict[max_pair[1]] = abs(\n                self.head2head_count(cand_a, cand_b)\n                - self.head2head_count(cand_b, cand_a)\n            )\n\n        return pairwise_dict\n\n    def build_graph(self) -&gt; nx.DiGraph:\n        G = nx.DiGraph()\n        G.add_nodes_from(self.candidates)\n        for e in self.pairwise_dict.keys():\n            G.add_edge(e[0], e[1], weight=self.pairwise_dict[e])\n        return G\n\n    def draw(self, outfile=None):\n        \"\"\"\n        Draws pairwise comparison graph\n        \"\"\"\n        G = self.pairwise_graph\n\n        pos = nx.circular_layout(G)\n        nx.draw_networkx(\n            G,\n            pos,\n            with_labels=True,\n            node_size=500,\n            node_color=\"skyblue\",\n            edgelist=list(),\n        )\n        nx.draw_networkx_edges(\n            G,\n            pos,\n            edgelist=G.edges,\n            width=1.5,\n            edge_color=\"b\",\n            arrows=True,\n            alpha=1,\n            node_size=1000,\n            arrowsize=25,\n        )\n        edge_labels = {(i, j): G[i][j][\"weight\"] for i, j in G.edges()}\n        nx.draw_networkx_edge_labels(\n            G, pos, edge_labels=edge_labels, label_pos=0.5, font_size=10\n        )\n        # Out stuff\n        if outfile is not None:\n            plt.savefig(outfile)\n        else:\n            plt.show()\n        plt.close()\n\n    # More complicated Requests\n    def has_condorcet(self) -&gt; bool:\n        \"\"\"\n        Checks if graph has a condorcet winner\n\n        Returns:\n            True if condorcet winner exists, False otherwise\n        \"\"\"\n        dominating_tiers = self.dominating_tiers()\n        if len(dominating_tiers[0]) == 1:\n            return True\n        return False\n\n    def dominating_tiers(self) -&gt; list[set]:\n        \"\"\"\n        Finds dominating tiers within an election\n\n        Returns:\n            A list of dominating tiers\n        \"\"\"\n        beat_set_size_dict = {}\n        for i, cand in enumerate(self.candidates):\n            beat_set = set()\n            for j, other_cand in enumerate(self.candidates):\n                if i != j:\n                    if nx.has_path(self.pairwise_graph, cand, other_cand):\n                        beat_set.add(other_cand)\n            beat_set_size_dict[cand] = len(beat_set)\n\n        # We want to return candidates sorted and grouped by beat set size\n        tier_dict: dict = {}\n        for k, v in beat_set_size_dict.items():\n            if v in tier_dict.keys():\n                tier_dict[v].add(k)\n            else:\n                tier_dict[v] = {k}\n        tier_list = [tier_dict[k] for k in sorted(tier_dict.keys(), reverse=True)]\n        return tier_list\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.ballot_fill","title":"<code>ballot_fill(profile, ballot_length)</code>","text":"<p>Fills incomplete ballots for pairwise comparison</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def ballot_fill(self, profile: PreferenceProfile, ballot_length: int):\n    \"\"\"\n    Fills incomplete ballots for pairwise comparison\n    \"\"\"\n    cand_list = [{cand} for cand in profile.get_candidates()]\n    updated_ballot_list = []\n\n    for ballot in profile.get_ballots():\n        if len(ballot.ranking) &lt; ballot_length:\n            missing_cands = [\n                cand for cand in cand_list if cand not in ballot.ranking\n            ]\n            missing_cands_perms = list(\n                permutations(missing_cands, len(missing_cands))\n            )\n            frac_freq = ballot.weight / (len(missing_cands_perms))\n            for perm in missing_cands_perms:\n                updated_rank = ballot.ranking + list(perm)\n                updated_ballot = Ballot(\n                    ranking=updated_rank, weight=Fraction(frac_freq, 1)\n                )\n                updated_ballot_list.append(updated_ballot)\n        else:\n            updated_ballot_list.append(ballot)\n    return PreferenceProfile(ballots=updated_ballot_list)\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.compute_pairwise_dict","title":"<code>compute_pairwise_dict()</code>","text":"<p>Constructs dictionary where keys are tuples (cand_a, cand_b) containing two candidates and values is the frequency cand_a is preferred to cand_b</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def compute_pairwise_dict(self) -&gt; dict:\n    \"\"\"\n    Constructs dictionary where keys are tuples (cand_a, cand_b) containing\n    two candidates and values is the frequency cand_a is preferred to\n    cand_b\n    \"\"\"\n    pairwise_dict = {}  # {(cand_a, cand_b): freq cand_a is preferred over cand_b}\n    cand_pairs = combinations(self.candidates, 2)\n\n    for pair in cand_pairs:\n        cand_a, cand_b = pair[0], pair[1]\n        head_2_head_dict = {\n            (cand_a, cand_b): self.head2head_count(cand_a, cand_b),\n            (cand_b, cand_a): self.head2head_count(cand_b, cand_a),\n        }\n        max_pair = max(zip(head_2_head_dict.values(), head_2_head_dict.keys()))\n        pairwise_dict[max_pair[1]] = abs(\n            self.head2head_count(cand_a, cand_b)\n            - self.head2head_count(cand_b, cand_a)\n        )\n\n    return pairwise_dict\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.dominating_tiers","title":"<code>dominating_tiers()</code>","text":"<p>Finds dominating tiers within an election</p> <p>Returns:</p> Type Description <code>list[set]</code> <p>A list of dominating tiers</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def dominating_tiers(self) -&gt; list[set]:\n    \"\"\"\n    Finds dominating tiers within an election\n\n    Returns:\n        A list of dominating tiers\n    \"\"\"\n    beat_set_size_dict = {}\n    for i, cand in enumerate(self.candidates):\n        beat_set = set()\n        for j, other_cand in enumerate(self.candidates):\n            if i != j:\n                if nx.has_path(self.pairwise_graph, cand, other_cand):\n                    beat_set.add(other_cand)\n        beat_set_size_dict[cand] = len(beat_set)\n\n    # We want to return candidates sorted and grouped by beat set size\n    tier_dict: dict = {}\n    for k, v in beat_set_size_dict.items():\n        if v in tier_dict.keys():\n            tier_dict[v].add(k)\n        else:\n            tier_dict[v] = {k}\n    tier_list = [tier_dict[k] for k in sorted(tier_dict.keys(), reverse=True)]\n    return tier_list\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.draw","title":"<code>draw(outfile=None)</code>","text":"<p>Draws pairwise comparison graph</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def draw(self, outfile=None):\n    \"\"\"\n    Draws pairwise comparison graph\n    \"\"\"\n    G = self.pairwise_graph\n\n    pos = nx.circular_layout(G)\n    nx.draw_networkx(\n        G,\n        pos,\n        with_labels=True,\n        node_size=500,\n        node_color=\"skyblue\",\n        edgelist=list(),\n    )\n    nx.draw_networkx_edges(\n        G,\n        pos,\n        edgelist=G.edges,\n        width=1.5,\n        edge_color=\"b\",\n        arrows=True,\n        alpha=1,\n        node_size=1000,\n        arrowsize=25,\n    )\n    edge_labels = {(i, j): G[i][j][\"weight\"] for i, j in G.edges()}\n    nx.draw_networkx_edge_labels(\n        G, pos, edge_labels=edge_labels, label_pos=0.5, font_size=10\n    )\n    # Out stuff\n    if outfile is not None:\n        plt.savefig(outfile)\n    else:\n        plt.show()\n    plt.close()\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.has_condorcet","title":"<code>has_condorcet()</code>","text":"<p>Checks if graph has a condorcet winner</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if condorcet winner exists, False otherwise</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def has_condorcet(self) -&gt; bool:\n    \"\"\"\n    Checks if graph has a condorcet winner\n\n    Returns:\n        True if condorcet winner exists, False otherwise\n    \"\"\"\n    dominating_tiers = self.dominating_tiers()\n    if len(dominating_tiers[0]) == 1:\n        return True\n    return False\n</code></pre>"},{"location":"api/#votekit.graphs.pairwise_comparison_graph.PairwiseComparisonGraph.head2head_count","title":"<code>head2head_count(cand1, cand2)</code>","text":"<p>Counts head to head comparisons between two candidates</p> Source code in <code>src/votekit/graphs/pairwise_comparison_graph.py</code> <pre><code>def head2head_count(self, cand1, cand2) -&gt; Fraction:\n    \"\"\"\n    Counts head to head comparisons between two candidates\n    \"\"\"\n    count = 0\n    ballots_list = self.profile.get_ballots()\n    for ballot in ballots_list:\n        rank_list = ballot.ranking\n        for s in rank_list:\n            if cand1 in s:\n                count += ballot.weight\n                break\n            elif cand2 in s:\n                break\n    return Fraction(count)\n</code></pre>"},{"location":"api/#cvr-loaders","title":"CVR Loaders","text":""},{"location":"api/#votekit.cvr_loaders.load_blt","title":"<code>load_blt(fpath)</code>","text":"<p>Given a blt file path, loads cvr (blt is text-like format used for scottish election data)</p> <p>Parameters:</p> Name Type Description Default <code>fpath</code> <code>str</code> <p>Path to cvr file</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If fpath is invalid</p> <code>EmptyDataError</code> <p>If dataset is empty</p> <code>DataError</code> <p>If there is missing or incorrect metadata or candidate data</p> <p>Returns:</p> Type Description <code>PreferenceProfile</code> <p>A preference schedule representing all the ballots in the elction</p> <code>int</code> <p>Number of seats in the election</p> Source code in <code>src/votekit/cvr_loaders.py</code> <pre><code>def load_blt(fpath: str) -&gt; tuple[PreferenceProfile, int]:\n    \"\"\"\n    Given a blt file path, loads cvr (blt is text-like format used for scottish election data)\n\n    Args:\n        fpath: Path to cvr file\n\n    Raises:\n        FileNotFoundError: If fpath is invalid\n        EmptyDataError: If dataset is empty\n        DataError: If there is missing or incorrect metadata or candidate data\n\n    Returns:\n        A preference schedule representing all the ballots in the elction\n        Number of seats in the election\n    \"\"\"\n    ballots = []\n    names = []\n    name_map = {}\n    numbers = True\n    cands_included = False\n\n    if not os.path.isfile(fpath):\n        raise FileNotFoundError(f\"File with path {fpath} cannot be found\")\n    if os.path.getsize(fpath) == 0:\n        raise EmptyDataError(\"Dataset cannot be empty\")\n\n    with open(fpath, \"r\") as file:\n        for i, line in enumerate(file):\n            s = line.rstrip(\"\\n\").rstrip()\n            if i == 0:\n                # first number is number of candidates, second is number of seats to elect\n                metadata = [int(data) for data in s.split(\" \")]\n                if len(metadata) != 2:\n                    raise DataError(\n                        \"metadata (first line) should have two parameters\"\n                        \" (number of candidates, number of seats)\"\n                    )\n                seats = metadata[1]\n            # read in ballots, cleaning out rankings labeled '0' (designating end of line)\n            elif numbers:\n                ballot = [int(vote) for vote in s.split(\" \")]\n                num_votes = ballot[0]\n                # ballots terminate with a single row with the character '0'\n                if num_votes == 0:\n                    numbers = False\n                else:\n                    ranking = [rank for rank in list(ballot[1:]) if rank != 0]\n                    b = (ranking, num_votes)\n                    ballots.append(b)  # this is converted to the PP format later\n            # read in candidates\n            elif \"(\" in s:\n                cands_included = True\n                name_parts = s.strip('\"').split(\" \")\n                first_name = \" \".join(name_parts[:-2])\n                last_name = name_parts[-2]\n                party = name_parts[-1].strip(\"(\").strip(\")\")\n                names.append(str((first_name, last_name, party)))\n            else:\n                if len(names) != metadata[0]:\n                    err_message = (\n                        f\"Number of candidates listed, {len(names)},\" + f\" differs from\"\n                        f\"number of candidates recorded in metadata, {metadata[0]}\"\n                    )\n                    raise DataError(err_message)\n                # read in election location (do we need this?)\n                # location = s.strip(\"\\\"\")\n                if not cands_included:\n                    raise DataError(\"Candidates missing from file\")\n                # map candidate numbers onto their names and convert ballots to PP format\n                for i, name in enumerate(names):\n                    name_map[i + 1] = name\n                clean_ballots = [\n                    Ballot(\n                        ranking=[{name_map[cand]} for cand in ballot[0]],\n                        weight=Fraction(ballot[1]),\n                    )\n                    for ballot in ballots\n                ]\n\n        return PreferenceProfile(ballots=clean_ballots, candidates=names), seats\n</code></pre>"},{"location":"api/#votekit.cvr_loaders.load_csv","title":"<code>load_csv(fpath, rank_cols=[], *, weight_col=None, delimiter=None, id_col=None)</code>","text":"<p>Given a file path, loads cast vote records (cvr) with ranks as columns and voters as rows (empty cells are treated as None)</p> <p>Parameters:</p> Name Type Description Default <code>fpath</code> <code>str</code> <p>Path to cvr file</p> required <code>rank_cols</code> <code>list[int]</code> <p>list of column indexes that contain rankings, indexing starts from 0,         in order from top to bottom rank.         Default implies that all columns contain rankings.</p> <code>[]</code> <code>weight_col</code> <code>Optional[int]</code> <p>The column position for ballot weights if parsing Scottish elections like cvrs</p> <code>None</code> <code>delimiter</code> <code>Optional[str]</code> <p>The character that breaks up rows</p> <code>None</code> <code>id_col</code> <code>Optional[int]</code> <p>Index for the column with voter ids</p> <code>None</code> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If fpath is invalid</p> <code>EmptyDataError</code> <p>If dataset is empty</p> <code>ValueError</code> <p>If the voter id column has missing values</p> <code>DataError</code> <p>If the voter id column has duplicate values</p> <p>Returns:</p> Type Description <code>PreferenceProfile</code> <p>A preference profile that represents all the ballots in the election</p> Source code in <code>src/votekit/cvr_loaders.py</code> <pre><code>def load_csv(\n    fpath: str,\n    rank_cols: list[int] = [],\n    *,\n    weight_col: Optional[int] = None,\n    delimiter: Optional[str] = None,\n    id_col: Optional[int] = None,\n) -&gt; PreferenceProfile:\n    \"\"\"\n    Given a file path, loads cast vote records (cvr) with ranks as columns and voters as rows\n    (empty cells are treated as None)\n\n    Args:\n        fpath: Path to cvr file\n        rank_cols: list of column indexes that contain rankings, indexing starts from 0,\n                    in order from top to bottom rank.\n                    Default implies that all columns contain rankings.\n        weight_col: The column position for ballot weights\n            if parsing Scottish elections like cvrs\n        delimiter: The character that breaks up rows\n        id_col: Index for the column with voter ids\n\n    Raises:\n        FileNotFoundError: If fpath is invalid\n        EmptyDataError: If dataset is empty\n        ValueError: If the voter id column has missing values\n        DataError: If the voter id column has duplicate values\n\n    Returns:\n        A preference profile that represents all the ballots in the election\n    \"\"\"\n    if not os.path.isfile(fpath):\n        raise FileNotFoundError(f\"File with path {fpath} cannot be found\")\n\n    cvr_path = pathlib.Path(fpath)\n    df = pd.read_csv(\n        cvr_path,\n        on_bad_lines=\"error\",\n        encoding=\"utf8\",\n        index_col=False,\n        delimiter=delimiter,\n    )\n\n    if df.empty:\n        raise EmptyDataError(\"Dataset cannot be empty\")\n    if id_col is not None and df.iloc[:, id_col].isnull().values.any():  # type: ignore\n        raise ValueError(f\"Missing value(s) in column at index {id_col}\")\n    if id_col is not None and not df.iloc[:, id_col].is_unique:\n        raise DataError(f\"Duplicate value(s) in column at index {id_col}\")\n\n    if rank_cols:\n        if id_col is not None:\n            df = df.iloc[:, rank_cols+[id_col]]\n        else:\n            df = df.iloc[:, rank_cols]\n\n    ranks = list(df.columns)\n    if id_col is not None:\n        ranks.remove(df.columns[id_col])\n    grouped = df.groupby(ranks, dropna=False)\n    ballots = []\n\n    for group, group_df in grouped:\n        ranking = [{None} if pd.isnull(c) else {c} for c in group]\n\n\n        voters = None\n        if id_col is not None:\n            voters = set(group_df.iloc[:, id_col])\n        weight = len(group_df)\n        if weight_col is not None:\n            weight = sum(group_df.iloc[:, weight_col])\n        b = Ballot(ranking=ranking, weight=Fraction(weight), voters=voters)\n        ballots.append(b)\n\n    return PreferenceProfile(ballots=ballots)\n</code></pre>"},{"location":"api/#ballot-generators","title":"Ballot Generators","text":""},{"location":"api/#votekit.ballot_generator.BallotGenerator","title":"<code>BallotGenerator</code>","text":"<p>Base class for ballot generation models that use the candidate simplex (e.g. PlackettLuce, BradleyTerry, etc.)</p> <p>Attributes</p> <p><code>candidates</code> :   list of candidates in the election</p> <p><code>ballot_length</code> :   (Optional) length of ballots to generate. Defaults to the length of     <code>candidates</code></p> <p><code>pref_interval_by_bloc</code> :   dictionary mapping of slate to preference interval     (ex. {race: {candidate : interval length}})</p> <p><code>bloc_voter_prop</code> :   dictionary mapping of slate to voter proportions     (ex. {race: voter proportion}). Defaults to None</p> Note <ul> <li>Voter proportion for blocs must sum to 1</li> <li>Preference interval for candidates must sum to 1</li> <li>Slates and blocs must be equal</li> </ul> <p>Methods</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class BallotGenerator:\n    \"\"\"\n    Base class for ballot generation models that use the candidate simplex\n    (e.g. PlackettLuce, BradleyTerry, etc.)\n\n    **Attributes**\n\n    `candidates`\n    :   list of candidates in the election\n\n    `ballot_length`\n    :   (Optional) length of ballots to generate. Defaults to the length of\n        `candidates`\n\n    `pref_interval_by_bloc`\n    :   dictionary mapping of slate to preference interval\n        (ex. {race: {candidate : interval length}})\n\n    `bloc_voter_prop`\n    :   dictionary mapping of slate to voter proportions\n        (ex. {race: voter proportion}). Defaults to None\n\n    ???+ note\n\n        * Voter proportion for blocs must sum to 1\n        * Preference interval for candidates must sum to 1\n        * Slates and blocs must be equal\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        candidates: list,\n        *,\n        ballot_length: Optional[int] = None,\n        pref_interval_by_bloc=None,\n        bloc_voter_prop=None,\n    ):\n\n        self.ballot_length = (\n            ballot_length if ballot_length is not None else len(candidates)\n        )\n        self.candidates = candidates\n\n        if bloc_voter_prop and pref_interval_by_bloc:  # PL, BT, AC, CS\n            if round(sum(bloc_voter_prop.values())) != 1:\n                raise ValueError(\"Voter proportion for blocs must sum to 1\")\n            for interval in pref_interval_by_bloc.values():\n                if round(sum(interval.values())) != 1:\n                    raise ValueError(\"Preference interval for candidates must sum to 1\")\n            if bloc_voter_prop.keys() != pref_interval_by_bloc.keys():\n                raise ValueError(\"slates and blocs are not the same\")\n\n            self.pref_interval_by_bloc = pref_interval_by_bloc\n            self.bloc_voter_prop = bloc_voter_prop\n\n    @classmethod\n    def from_params(\n        cls,\n        slate_to_candidates: dict,\n        bloc_voter_prop: dict,\n        cohesion: dict,\n        alphas: dict,\n        **data,\n    ):\n        \"\"\"\n        Initializes a Ballot Generator by constructing a preference interval\n        from parameters; the prior parameters (if inputted) will be overwritten\n\n        Args:\n            slate_to_candidate (dict): a mapping of slate to candidates\n                (ex. {race: [candidate]})\n            bloc_voter_prop (dict): a mapping of the percentage of total voters\n                 per bloc (ex. {race: 0.5})\n            cohesion (dict): cohension factor for each bloc\n            alphas (dict): alpha for the dirchlet distribution of each bloc\n\n        Raises:\n            ValueError: if the voter proportion for blocs don't sum to 1\n            ValueError: slates and blocs are not the same\n\n        Returns:\n            BallotGenerator: initialized ballot generator\n        \"\"\"\n\n        if sum(bloc_voter_prop.values()) != 1.0:\n            raise ValueError(\n                f\"bloc proportions ({bloc_voter_prop.values()}) do not equal 1\"\n            )\n        if slate_to_candidates.keys() != bloc_voter_prop.keys():\n            raise ValueError(\"slates and blocs are not the same\")\n\n        def _construct_preference_interval(\n            alphas: dict, cohesion: int, bloc: str, slate_to_cands: dict\n        ) -&gt; dict:\n            intervals = {}\n\n            for group, alpha in alphas.items():\n                num_cands = len(slate_to_cands[group])\n                alpha = [alpha] * num_cands\n                probs = list(np.random.default_rng().dirichlet(alpha=alpha))\n                for prob, cand in zip(probs, slate_to_cands[group]):\n                    if group == bloc:  # e.g W for W cands\n                        pi = cohesion\n                    else:  # e.g W for POC cands\n                        pi = 1 - cohesion\n                    intervals[cand] = pi * prob\n\n            return intervals\n\n        interval_by_bloc = {}\n        for bloc in bloc_voter_prop:\n            interval = _construct_preference_interval(\n                alphas[bloc], cohesion[bloc], bloc, slate_to_candidates\n            )\n            interval_by_bloc[bloc] = interval\n\n        if \"candidates\" not in data:\n            cands = list(\n                {cand for cands in slate_to_candidates.values() for cand in cands}\n            )\n            data[\"candidates\"] = cands\n\n        if \"pref_interval_by_bloc\" not in data:\n            data[\"pref_interval_by_bloc\"] = interval_by_bloc\n\n        if \"bloc_voter_prop\" not in data:\n            data[\"bloc_voter_prop\"] = bloc_voter_prop\n\n        generator = cls(**data)\n\n        if isinstance(generator, (AlternatingCrossover, CambridgeSampler)):\n            generator.slate_to_candidates = slate_to_candidates\n\n        return generator\n\n    @abstractmethod\n    def generate_profile(self, number_of_ballots: int) -&gt; PreferenceProfile:\n        \"\"\"\n        Generates a `PreferenceProfile`\n\n        Args:\n            number_of_ballots (int): number of ballots to generate\n        Returns:\n            PreferenceProfile: a generated `PreferenceProfile`\n        \"\"\"\n        pass\n\n    @staticmethod\n    def round_num(num: float) -&gt; int:\n        \"\"\"\n        rounds up or down a float randomly\n\n        Args:\n            num (float): number to round\n\n        Returns:\n            int: a whole number\n        \"\"\"\n        rand = np.random.random()\n        return math.ceil(num) if rand &gt; 0.5 else math.floor(num)\n\n    @staticmethod\n    def ballot_pool_to_profile(ballot_pool, candidates) -&gt; PreferenceProfile:\n        \"\"\"\n        Given a list of ballots and candidates, convert them into a `PreferenceProfile`\n\n        Args:\n            ballot_pool (list of tuple): a list of ballots, with tuple as their ranking\n            candidates (list): a list of candidates\n\n        Returns:\n            PreferenceProfile: a preference profile representing the ballots in the election\n        \"\"\"\n        ranking_counts: dict[tuple, int] = {}\n        ballot_list: list[Ballot] = []\n\n        for ranking in ballot_pool:\n            tuple_rank = tuple(ranking)\n            ranking_counts[tuple_rank] = (\n                ranking_counts[tuple_rank] + 1 if tuple_rank in ranking_counts else 1\n            )\n\n        for ranking, count in ranking_counts.items():\n            rank = [set([cand]) for cand in ranking]\n            b = Ballot(ranking=rank, weight=Fraction(count))\n            ballot_list.append(b)\n\n        return PreferenceProfile(ballots=ballot_list, candidates=candidates)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotGenerator.ballot_pool_to_profile","title":"<code>ballot_pool_to_profile(ballot_pool, candidates)</code>  <code>staticmethod</code>","text":"<p>Given a list of ballots and candidates, convert them into a <code>PreferenceProfile</code></p> <p>Parameters:</p> Name Type Description Default <code>ballot_pool</code> <code>list of tuple</code> <p>a list of ballots, with tuple as their ranking</p> required <code>candidates</code> <code>list</code> <p>a list of candidates</p> required <p>Returns:</p> Name Type Description <code>PreferenceProfile</code> <code>PreferenceProfile</code> <p>a preference profile representing the ballots in the election</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>@staticmethod\ndef ballot_pool_to_profile(ballot_pool, candidates) -&gt; PreferenceProfile:\n    \"\"\"\n    Given a list of ballots and candidates, convert them into a `PreferenceProfile`\n\n    Args:\n        ballot_pool (list of tuple): a list of ballots, with tuple as their ranking\n        candidates (list): a list of candidates\n\n    Returns:\n        PreferenceProfile: a preference profile representing the ballots in the election\n    \"\"\"\n    ranking_counts: dict[tuple, int] = {}\n    ballot_list: list[Ballot] = []\n\n    for ranking in ballot_pool:\n        tuple_rank = tuple(ranking)\n        ranking_counts[tuple_rank] = (\n            ranking_counts[tuple_rank] + 1 if tuple_rank in ranking_counts else 1\n        )\n\n    for ranking, count in ranking_counts.items():\n        rank = [set([cand]) for cand in ranking]\n        b = Ballot(ranking=rank, weight=Fraction(count))\n        ballot_list.append(b)\n\n    return PreferenceProfile(ballots=ballot_list, candidates=candidates)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotGenerator.from_params","title":"<code>from_params(slate_to_candidates, bloc_voter_prop, cohesion, alphas, **data)</code>  <code>classmethod</code>","text":"<p>Initializes a Ballot Generator by constructing a preference interval from parameters; the prior parameters (if inputted) will be overwritten</p> <p>Parameters:</p> Name Type Description Default <code>slate_to_candidate</code> <code>dict</code> <p>a mapping of slate to candidates (ex. {race: [candidate]})</p> required <code>bloc_voter_prop</code> <code>dict</code> <p>a mapping of the percentage of total voters  per bloc (ex. {race: 0.5})</p> required <code>cohesion</code> <code>dict</code> <p>cohension factor for each bloc</p> required <code>alphas</code> <code>dict</code> <p>alpha for the dirchlet distribution of each bloc</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the voter proportion for blocs don't sum to 1</p> <code>ValueError</code> <p>slates and blocs are not the same</p> <p>Returns:</p> Name Type Description <code>BallotGenerator</code> <p>initialized ballot generator</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>@classmethod\ndef from_params(\n    cls,\n    slate_to_candidates: dict,\n    bloc_voter_prop: dict,\n    cohesion: dict,\n    alphas: dict,\n    **data,\n):\n    \"\"\"\n    Initializes a Ballot Generator by constructing a preference interval\n    from parameters; the prior parameters (if inputted) will be overwritten\n\n    Args:\n        slate_to_candidate (dict): a mapping of slate to candidates\n            (ex. {race: [candidate]})\n        bloc_voter_prop (dict): a mapping of the percentage of total voters\n             per bloc (ex. {race: 0.5})\n        cohesion (dict): cohension factor for each bloc\n        alphas (dict): alpha for the dirchlet distribution of each bloc\n\n    Raises:\n        ValueError: if the voter proportion for blocs don't sum to 1\n        ValueError: slates and blocs are not the same\n\n    Returns:\n        BallotGenerator: initialized ballot generator\n    \"\"\"\n\n    if sum(bloc_voter_prop.values()) != 1.0:\n        raise ValueError(\n            f\"bloc proportions ({bloc_voter_prop.values()}) do not equal 1\"\n        )\n    if slate_to_candidates.keys() != bloc_voter_prop.keys():\n        raise ValueError(\"slates and blocs are not the same\")\n\n    def _construct_preference_interval(\n        alphas: dict, cohesion: int, bloc: str, slate_to_cands: dict\n    ) -&gt; dict:\n        intervals = {}\n\n        for group, alpha in alphas.items():\n            num_cands = len(slate_to_cands[group])\n            alpha = [alpha] * num_cands\n            probs = list(np.random.default_rng().dirichlet(alpha=alpha))\n            for prob, cand in zip(probs, slate_to_cands[group]):\n                if group == bloc:  # e.g W for W cands\n                    pi = cohesion\n                else:  # e.g W for POC cands\n                    pi = 1 - cohesion\n                intervals[cand] = pi * prob\n\n        return intervals\n\n    interval_by_bloc = {}\n    for bloc in bloc_voter_prop:\n        interval = _construct_preference_interval(\n            alphas[bloc], cohesion[bloc], bloc, slate_to_candidates\n        )\n        interval_by_bloc[bloc] = interval\n\n    if \"candidates\" not in data:\n        cands = list(\n            {cand for cands in slate_to_candidates.values() for cand in cands}\n        )\n        data[\"candidates\"] = cands\n\n    if \"pref_interval_by_bloc\" not in data:\n        data[\"pref_interval_by_bloc\"] = interval_by_bloc\n\n    if \"bloc_voter_prop\" not in data:\n        data[\"bloc_voter_prop\"] = bloc_voter_prop\n\n    generator = cls(**data)\n\n    if isinstance(generator, (AlternatingCrossover, CambridgeSampler)):\n        generator.slate_to_candidates = slate_to_candidates\n\n    return generator\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotGenerator.generate_profile","title":"<code>generate_profile(number_of_ballots)</code>  <code>abstractmethod</code>","text":"<p>Generates a <code>PreferenceProfile</code></p> <p>Parameters:</p> Name Type Description Default <code>number_of_ballots</code> <code>int</code> <p>number of ballots to generate</p> required <p>Returns:     PreferenceProfile: a generated <code>PreferenceProfile</code></p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>@abstractmethod\ndef generate_profile(self, number_of_ballots: int) -&gt; PreferenceProfile:\n    \"\"\"\n    Generates a `PreferenceProfile`\n\n    Args:\n        number_of_ballots (int): number of ballots to generate\n    Returns:\n        PreferenceProfile: a generated `PreferenceProfile`\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotGenerator.round_num","title":"<code>round_num(num)</code>  <code>staticmethod</code>","text":"<p>rounds up or down a float randomly</p> <p>Parameters:</p> Name Type Description Default <code>num</code> <code>float</code> <p>number to round</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>a whole number</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>@staticmethod\ndef round_num(num: float) -&gt; int:\n    \"\"\"\n    rounds up or down a float randomly\n\n    Args:\n        num (float): number to round\n\n    Returns:\n        int: a whole number\n    \"\"\"\n    rand = np.random.random()\n    return math.ceil(num) if rand &gt; 0.5 else math.floor(num)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotSimplex","title":"<code>BallotSimplex</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>Base class for ballot generation models that use the ballot simplex (e.g. ImpartialCulture, ImpartialAnonymousCulture)</p> <p>Attributes</p> <p><code>alpha</code> :   (float) alpha parameter for ballot simplex. Defaults to None</p> <p><code>point</code> :   dictionary representing a point in the ballot simplex with candidate as     keys and electoral support as values. Defaults to None</p> Note <p>Point and alpha arguments must be included to intialize</p> <p>Methods</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class BallotSimplex(BallotGenerator):\n    \"\"\"\n    Base class for ballot generation models that use the ballot simplex\n    (e.g. ImpartialCulture, ImpartialAnonymousCulture)\n\n    **Attributes**\n\n    `alpha`\n    :   (float) alpha parameter for ballot simplex. Defaults to None\n\n    `point`\n    :   dictionary representing a point in the ballot simplex with candidate as\n        keys and electoral support as values. Defaults to None\n\n    ???+ note\n\n        Point and alpha arguments must be included to intialize\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self, alpha: Optional[float] = None, point: Optional[dict] = None, **data\n    ):\n        if alpha is None and point is None:\n            raise AttributeError(\"point or alpha must be initialized\")\n        self.alpha = alpha\n        if alpha == float(\"inf\"):\n            self.alpha = 1e20\n        if alpha == 0:\n            self.alpha = 1e-10\n        self.point = point\n        super().__init__(**data)\n\n    @classmethod\n    def from_point(cls, point: dict, **data):\n        \"\"\"\n        Initializes a Ballot Simplex model from a point in the dirichlet distribution\n\n        Args:\n            point (dict): a mapping of candidate to candidate support\n\n        Raises:\n            ValueError: if the candidate support does not sum to 1\n\n        Returns:\n            BallotSimplex: initialized from point\n        \"\"\"\n        if sum(point.values()) != 1.0:\n            raise ValueError(\n                f\"probability distribution from point ({point.values()}) does not sum to 1\"\n            )\n        return cls(point=point, **data)\n\n    @classmethod\n    def from_alpha(cls, alpha: float, **data):\n        \"\"\"\n        Initializes a Ballot Simplex model from an alpha value for the dirichlet\n        distribution\n\n        Args:\n            alpha (float): an alpha parameter for the dirichlet distribution\n\n        Returns:\n            BallotSimplex: initialized from alpha\n        \"\"\"\n\n        return cls(alpha=alpha, **data)\n\n    def generate_profile(self, number_of_ballots) -&gt; PreferenceProfile:\n        perm_set = it.permutations(self.candidates, self.ballot_length)\n\n        perm_rankings = [list(value) for value in perm_set]\n\n        if self.alpha is not None:\n            draw_probabilities = list(\n                np.random.default_rng().dirichlet([self.alpha] * len(perm_rankings))\n            )\n        elif self.point:\n            # calculates probabilities for each ranking\n            # using probability distribution for candidate support\n            draw_probabilities = [\n                reduce(\n                    lambda prod, cand: prod * self.point[cand] if self.point else 0,\n                    ranking,\n                    1.0,\n                )\n                for ranking in perm_rankings\n            ]\n            draw_probabilities = [\n                prob / sum(draw_probabilities) for prob in draw_probabilities\n            ]\n\n        ballot_pool = []\n\n        for _ in range(number_of_ballots):\n            index = np.random.choice(\n                range(len(perm_rankings)), 1, p=draw_probabilities\n            )[0]\n            ballot_pool.append(perm_rankings[index])\n\n        return self.ballot_pool_to_profile(ballot_pool, self.candidates)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotSimplex.from_alpha","title":"<code>from_alpha(alpha, **data)</code>  <code>classmethod</code>","text":"<p>Initializes a Ballot Simplex model from an alpha value for the dirichlet distribution</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>float</code> <p>an alpha parameter for the dirichlet distribution</p> required <p>Returns:</p> Name Type Description <code>BallotSimplex</code> <p>initialized from alpha</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>@classmethod\ndef from_alpha(cls, alpha: float, **data):\n    \"\"\"\n    Initializes a Ballot Simplex model from an alpha value for the dirichlet\n    distribution\n\n    Args:\n        alpha (float): an alpha parameter for the dirichlet distribution\n\n    Returns:\n        BallotSimplex: initialized from alpha\n    \"\"\"\n\n    return cls(alpha=alpha, **data)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BallotSimplex.from_point","title":"<code>from_point(point, **data)</code>  <code>classmethod</code>","text":"<p>Initializes a Ballot Simplex model from a point in the dirichlet distribution</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>dict</code> <p>a mapping of candidate to candidate support</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>if the candidate support does not sum to 1</p> <p>Returns:</p> Name Type Description <code>BallotSimplex</code> <p>initialized from point</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>@classmethod\ndef from_point(cls, point: dict, **data):\n    \"\"\"\n    Initializes a Ballot Simplex model from a point in the dirichlet distribution\n\n    Args:\n        point (dict): a mapping of candidate to candidate support\n\n    Raises:\n        ValueError: if the candidate support does not sum to 1\n\n    Returns:\n        BallotSimplex: initialized from point\n    \"\"\"\n    if sum(point.values()) != 1.0:\n        raise ValueError(\n            f\"probability distribution from point ({point.values()}) does not sum to 1\"\n        )\n    return cls(point=point, **data)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.PlackettLuce","title":"<code>PlackettLuce</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>Class for generating ballots using a Plackett-Luce model</p> <p>Attributes</p> <p><code>pref_interval_by_bloc</code> :   dictionary mapping of slate to preference interval     (ex. {race: {candidate : interval length}})</p> <p><code>bloc_voter_prop</code> :   dictionary mapping of slate to voter proportions (ex. {race: voter proportion})</p> <p>Methods</p> <p>See <code>BallotGenerator</code> base class</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class PlackettLuce(BallotGenerator):\n    \"\"\"\n    Class for generating ballots using a Plackett-Luce model\n\n    **Attributes**\n\n    `pref_interval_by_bloc`\n    :   dictionary mapping of slate to preference interval\n        (ex. {race: {candidate : interval length}})\n\n    `bloc_voter_prop`\n    :   dictionary mapping of slate to voter proportions (ex. {race: voter proportion})\n\n    **Methods**\n\n    See `BallotGenerator` base class\n    \"\"\"\n\n    def __init__(self, **data):\n\n        # Call the parent class's __init__ method to handle common parameters\n        super().__init__(**data)\n\n    def generate_profile(self, number_of_ballots) -&gt; PreferenceProfile:\n        ballot_pool = []\n\n        for bloc in self.bloc_voter_prop.keys():\n            # number of voters in this bloc\n            num_ballots = self.round_num(number_of_ballots * self.bloc_voter_prop[bloc])\n            pref_interval_dict = self.pref_interval_by_bloc[bloc]\n            # creates the interval of probabilities for candidates supported by this block\n            cand_support_vec = [pref_interval_dict[cand] for cand in self.candidates]\n\n            for _ in range(num_ballots):\n                # generates ranking based on probability distribution of candidate support\n                ballot = list(\n                    np.random.choice(\n                        self.candidates,\n                        self.ballot_length,\n                        p=cand_support_vec,\n                        replace=False,\n                    )\n                )\n\n                ballot_pool.append(ballot)\n\n        pp = self.ballot_pool_to_profile(\n            ballot_pool=ballot_pool, candidates=self.candidates\n        )\n        return pp\n</code></pre>"},{"location":"api/#votekit.ballot_generator.BradleyTerry","title":"<code>BradleyTerry</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>Class for generating ballots useing a Bradley-Terry model</p> <p>Attributes</p> <p><code>pref_interval_by_bloc</code> :   dictionary mapping of slate to preference interval     (ex. {race: {candidate : interval length}})</p> <p><code>bloc_voter_prop</code> :   dictionary mapping of slate to voter proportions     (ex. {race: voter proportion})</p> <p>Methods</p> <p>See <code>BallotGenerator</code> base class</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class BradleyTerry(BallotGenerator):\n    \"\"\"\n    Class for generating ballots useing a Bradley-Terry model\n\n    **Attributes**\n\n    `pref_interval_by_bloc`\n    :   dictionary mapping of slate to preference interval\n        (ex. {race: {candidate : interval length}})\n\n    `bloc_voter_prop`\n    :   dictionary mapping of slate to voter proportions\n        (ex. {race: voter proportion})\n\n    **Methods**\n\n    See `BallotGenerator` base class\n    \"\"\"\n\n    def __init__(self, **data):\n\n        # Call the parent class's __init__ method to handle common parameters\n        super().__init__(**data)\n\n    def _calc_prob(self, permutations: list[tuple], cand_support_dict: dict) -&gt; dict:\n        \"\"\"\n        given a list of rankings and the preference interval, \\\n        calculates the probability of observing each ranking\n\n        Args:\n            permutations (list[tuple]): a list of permuted rankings\n            cand_support_dict (dict): a mapping from candidate to their \\\n            support (preference interval)\n\n        Returns:\n            dict: a mapping of the rankings to their probability\n        \"\"\"\n        ranking_to_prob = {}\n        for ranking in permutations:\n            prob = 1\n            for i in range(len(ranking)):\n                cand_i = ranking[i]\n                greater_cand_support = cand_support_dict[cand_i]\n                for j in range(i + 1, len(ranking)):\n                    cand_j = ranking[j]\n                    cand_support = cand_support_dict[cand_j]\n                    prob *= greater_cand_support / (greater_cand_support + cand_support)\n            ranking_to_prob[ranking] = prob\n        return ranking_to_prob\n\n    def generate_profile(self, number_of_ballots) -&gt; PreferenceProfile:\n\n        permutations = list(it.permutations(self.candidates, self.ballot_length))\n        ballot_pool: list[list] = []\n\n        for bloc in self.bloc_voter_prop.keys():\n            num_ballots = self.round_num(number_of_ballots * self.bloc_voter_prop[bloc])\n            pref_interval_dict = self.pref_interval_by_bloc[bloc]\n\n            ranking_to_prob = self._calc_prob(\n                permutations=permutations, cand_support_dict=pref_interval_dict\n            )\n\n            indices = range(len(ranking_to_prob))\n            prob_distrib = list(ranking_to_prob.values())\n            prob_distrib = [float(p) / sum(prob_distrib) for p in prob_distrib]\n\n            ballots_indices = np.random.choice(\n                indices,\n                num_ballots,\n                p=prob_distrib,\n                replace=True,\n            )\n\n            rankings = list(ranking_to_prob.keys())\n            ballots = [rankings[i] for i in ballots_indices]\n\n            ballot_pool = ballot_pool + ballots\n\n        pp = self.ballot_pool_to_profile(\n            ballot_pool=ballot_pool, candidates=self.candidates\n        )\n        return pp\n</code></pre>"},{"location":"api/#votekit.ballot_generator.AlternatingCrossover","title":"<code>AlternatingCrossover</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>Class for Alternating Crossover style of generating ballots</p> <p>Attributes</p> <p><code>pref_interval_by_bloc</code> :   dictionary mapping of slate to preference interval     (ex. {race: {candidate : interval length}})</p> <p><code>bloc_voter_prop</code> :   dictionary mapping of slate to voter proportions     (ex. {race: voter proportion})</p> <p><code>slate_to_candidate</code> :   dictionary mapping of slate to candidates (ex. {race: [candidate]})</p> <p><code>bloc_crossover_rate</code> :   dictionary mapping of percentage of crossover voters per bloc     ex. {race: {other_race: 0.5}})</p> <p>Methods</p> <p>See <code>BallotGenerator</code> base class</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class AlternatingCrossover(BallotGenerator):\n    \"\"\"\n    Class for Alternating Crossover style of generating ballots\n\n    **Attributes**\n\n    `pref_interval_by_bloc`\n    :   dictionary mapping of slate to preference interval\n        (ex. {race: {candidate : interval length}})\n\n    `bloc_voter_prop`\n    :   dictionary mapping of slate to voter proportions\n        (ex. {race: voter proportion})\n\n    `slate_to_candidate`\n    :   dictionary mapping of slate to candidates (ex. {race: [candidate]})\n\n    `bloc_crossover_rate`\n    :   dictionary mapping of percentage of crossover voters per bloc\n        ex. {race: {other_race: 0.5}})\n\n    **Methods**\n\n    See `BallotGenerator` base class\n    \"\"\"\n\n    def __init__(\n        self,\n        slate_to_candidates=None,\n        bloc_crossover_rate=None,\n        **data,\n    ):\n\n        # Call the parent class's __init__ method to handle common parameters\n        super().__init__(**data)\n\n        self.slate_to_candidates = slate_to_candidates\n        self.bloc_crossover_rate = bloc_crossover_rate\n\n    def generate_profile(self, number_of_ballots) -&gt; PreferenceProfile:\n\n        ballot_pool = []\n\n        for bloc in self.bloc_voter_prop.keys():\n\n            num_ballots = self.round_num(number_of_ballots * self.bloc_voter_prop[bloc])\n            crossover_dict = self.bloc_crossover_rate[bloc]\n            pref_interval_dict = self.pref_interval_by_bloc[bloc]\n\n            # generates crossover ballots from each bloc (allowing for more than two blocs)\n            for opposing_slate in crossover_dict.keys():\n                crossover_rate = crossover_dict[opposing_slate]\n                num_crossover_ballots = self.round_num(crossover_rate * num_ballots)\n\n                opposing_cands = self.slate_to_candidates[opposing_slate]\n                bloc_cands = self.slate_to_candidates[bloc]\n\n                for _ in range(num_crossover_ballots):\n                    pref_for_opposing = [\n                        pref_interval_dict[cand] for cand in opposing_cands\n                    ]\n                    # convert to probability distribution\n                    pref_for_opposing = [\n                        p / sum(pref_for_opposing) for p in pref_for_opposing\n                    ]\n\n                    pref_for_bloc = [pref_interval_dict[cand] for cand in bloc_cands]\n                    # convert to probability distribution\n                    pref_for_bloc = [p / sum(pref_for_bloc) for p in pref_for_bloc]\n\n                    bloc_cands = list(\n                        np.random.choice(\n                            bloc_cands,\n                            p=pref_for_bloc,\n                            size=len(bloc_cands),\n                            replace=False,\n                        )\n                    )\n                    opposing_cands = list(\n                        np.random.choice(\n                            opposing_cands,\n                            size=len(opposing_cands),\n                            p=pref_for_opposing,\n                            replace=False,\n                        )\n                    )\n\n                    # alternate the bloc and opposing bloc candidates to create crossover ballots\n                    if bloc != opposing_slate:  # alternate\n                        ballot = [\n                            item\n                            for pair in zip(opposing_cands, bloc_cands)\n                            for item in pair\n                            if item is not None\n                        ]\n\n                    # check that ballot_length is shorter than total number of cands\n                    ballot_pool.append(ballot)\n\n                # Bloc ballots\n                for _ in range(num_ballots - num_crossover_ballots):\n                    ballot = bloc_cands + opposing_cands\n                    ballot_pool.append(ballot)\n\n        pp = self.ballot_pool_to_profile(\n            ballot_pool=ballot_pool, candidates=self.candidates\n        )\n        return pp\n</code></pre>"},{"location":"api/#votekit.ballot_generator.CambridgeSampler","title":"<code>CambridgeSampler</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>Class for generating ballots based on historical RCV elections occuring in Cambridge. Alternative election data can be used if specified</p> <p>Attributes</p> <p><code>slate_to_candidate</code> :   dictionary mapping of slate to candidates (ex. {race: [candidate]})</p> <p><code>pref_interval_by_bloc</code> :   dictionary mapping of bloc to preference interval     (ex. {race: {candidate : interval length}})</p> <p><code>path</code> :   file path to an election data file to sample from. Defaults to Cambridge elections</p> <p>Methods</p> <p>See <code>BallotGenerator</code> base class</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class CambridgeSampler(BallotGenerator):\n    \"\"\"\n    Class for generating ballots based on historical RCV elections occuring\n    in Cambridge. Alternative election data can be used if specified\n\n    **Attributes**\n\n    `slate_to_candidate`\n    :   dictionary mapping of slate to candidates (ex. {race: [candidate]})\n\n    `pref_interval_by_bloc`\n    :   dictionary mapping of bloc to preference interval\n        (ex. {race: {candidate : interval length}})\n\n    `path`\n    :   file path to an election data file to sample from. Defaults to Cambridge elections\n\n    **Methods**\n\n    See `BallotGenerator` base class\n    \"\"\"\n\n    def __init__(\n        self,\n        slate_to_candidates=None,\n        bloc_crossover_rate=None,\n        path: Optional[Path] = None,\n        **data,\n    ):\n\n        # Call the parent class's __init__ method to handle common parameters\n        super().__init__(**data)\n\n        self.slate_to_candidates = slate_to_candidates\n        self.bloc_crossover_rate = bloc_crossover_rate\n\n        if path:\n            self.path = path\n        else:\n            BASE_DIR = Path(__file__).resolve().parent\n            DATA_DIR = BASE_DIR / \"data/\"\n            self.path = Path(DATA_DIR, \"Cambridge_09to17_ballot_types.p\")\n\n    def generate_profile(self, number_of_ballots: int) -&gt; PreferenceProfile:\n\n        with open(self.path, \"rb\") as pickle_file:\n            ballot_frequencies = pickle.load(pickle_file)\n\n        ballot_pool = []\n\n        blocs = self.slate_to_candidates.keys()\n        for bloc in blocs:\n            # compute the number of voters in this bloc\n            bloc_voters = self.round_num(self.bloc_voter_prop[bloc] * number_of_ballots)\n\n            # store the opposition bloc\n            opp_bloc = next(iter(set(blocs).difference(set(bloc))))\n\n            # compute how many ballots list a bloc candidate first\n            bloc_first_count = sum(\n                [\n                    freq\n                    for ballot, freq in ballot_frequencies.items()\n                    if ballot[0] == bloc\n                ]\n            )\n\n            # Compute the pref interval for this bloc\n            pref_interval_dict = self.pref_interval_by_bloc[bloc]\n\n            # compute the relative probabilities of each ballot\n            # sorted by ones where the ballot lists the bloc first\n            # and those that list the opp first\n            prob_ballot_given_bloc_first = {\n                ballot: freq / bloc_first_count\n                for ballot, freq in ballot_frequencies.items()\n                if ballot[0] == bloc\n            }\n            prob_ballot_given_opp_first = {\n                ballot: freq / bloc_first_count\n                for ballot, freq in ballot_frequencies.items()\n                if ballot[0] == opp_bloc\n            }\n\n            # Generate ballots\n            for _ in range(bloc_voters):\n                # Randomly choose first choice based off\n                # bloc crossover rate\n                first_choice = np.random.choice(\n                    [bloc, opp_bloc],\n                    p=[\n                        1 - self.bloc_crossover_rate[bloc][opp_bloc],\n                        self.bloc_crossover_rate[bloc][opp_bloc],\n                    ],\n                )\n                # Based on first choice, randomly choose\n                # ballots weighted by Cambridge frequency\n                if first_choice == bloc:\n                    bloc_ordering = random.choices(\n                        list(prob_ballot_given_bloc_first.keys()),\n                        weights=list(prob_ballot_given_bloc_first.values()),\n                        k=1,\n                    )[0]\n                else:\n                    bloc_ordering = random.choices(\n                        list(prob_ballot_given_opp_first.keys()),\n                        weights=list(prob_ballot_given_opp_first.values()),\n                        k=1,\n                    )[0]\n\n                # Now turn bloc ordering into candidate ordering\n                pl_ordering = list(\n                    np.random.choice(\n                        list(pref_interval_dict.keys()),\n                        self.ballot_length,\n                        p=list(pref_interval_dict.values()),\n                        replace=False,\n                    )\n                )\n                ordered_bloc_slate = [\n                    c for c in pl_ordering if c in self.slate_to_candidates[bloc]\n                ]\n                ordered_opp_slate = [\n                    c for c in pl_ordering if c in self.slate_to_candidates[opp_bloc]\n                ]\n\n                # Fill in the bloc slots as determined\n                # With the candidate ordering generated with PL\n                full_ballot = []\n                for b in bloc_ordering:\n                    if b == bloc:\n                        if ordered_bloc_slate:\n                            full_ballot.append(ordered_bloc_slate.pop(0))\n                    else:\n                        if ordered_opp_slate:\n                            full_ballot.append(ordered_opp_slate.pop(0))\n\n                ballot_pool.append(tuple(full_ballot))\n\n        pp = self.ballot_pool_to_profile(\n            ballot_pool=ballot_pool, candidates=self.candidates\n        )\n        return pp\n</code></pre>"},{"location":"api/#votekit.ballot_generator.OneDimSpatial","title":"<code>OneDimSpatial</code>","text":"<p>             Bases: <code>BallotGenerator</code></p> <p>1-D spatial model for ballot generation</p> <p>Attributes</p> <p>See <code>BallotGenerator</code> base class</p> <p>Methods</p> <p>See <code>BallotGenerator</code> base class</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class OneDimSpatial(BallotGenerator):\n    \"\"\"\n    1-D spatial model for ballot generation\n\n    **Attributes**\n\n    See `BallotGenerator` base class\n\n    **Methods**\n\n    See `BallotGenerator` base class\n    \"\"\"\n\n    def generate_profile(self, number_of_ballots) -&gt; PreferenceProfile:\n        candidate_position_dict = {c: np.random.normal(0, 1) for c in self.candidates}\n        voter_positions = np.random.normal(0, 1, number_of_ballots)\n\n        ballot_pool = []\n\n        for vp in voter_positions:\n            distance_dict = {\n                c: abs(v - vp) for c, v, in candidate_position_dict.items()\n            }\n            candidate_order = sorted(distance_dict, key=distance_dict.__getitem__)\n            ballot_pool.append(candidate_order)\n\n        return self.ballot_pool_to_profile(ballot_pool, self.candidates)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.ImpartialCulture","title":"<code>ImpartialCulture</code>","text":"<p>             Bases: <code>BallotSimplex</code></p> <p>Impartial Culture model with an alpha value of 1e10 (should be infinity theoretically)</p> <p>Attributes</p> <p>See <code>BallotSimplex</code> object</p> <p>Methods</p> <p>See <code>BallotSimplex</code> object</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class ImpartialCulture(BallotSimplex):\n    \"\"\"\n    Impartial Culture model with an alpha value of 1e10 (should be infinity theoretically)\n\n    **Attributes**\n\n    See `BallotSimplex` object\n\n    **Methods**\n\n    See `BallotSimplex` object\n    \"\"\"\n\n    def __init__(self, **data):\n        super().__init__(alpha=float(\"inf\"), **data)\n</code></pre>"},{"location":"api/#votekit.ballot_generator.ImpartialAnonymousCulture","title":"<code>ImpartialAnonymousCulture</code>","text":"<p>             Bases: <code>BallotSimplex</code></p> <p>Impartial Anonymous Culture model with an alpha value of 1</p> <p>Attributes</p> <p>See <code>BallotSimplex</code> base class</p> <p>Methods</p> <p>See <code>BallotSimplex</code> base class</p> Source code in <code>src/votekit/ballot_generator.py</code> <pre><code>class ImpartialAnonymousCulture(BallotSimplex):\n    \"\"\"\n    Impartial Anonymous Culture model with an alpha value of 1\n\n     **Attributes**\n\n    See `BallotSimplex` base class\n\n    **Methods**\n\n    See `BallotSimplex` base class\n    \"\"\"\n\n    def __init__(self, **data):\n        super().__init__(alpha=1, **data)\n</code></pre>"},{"location":"api/#elections","title":"Elections","text":""},{"location":"api/#votekit.elections.election_types.Bloc","title":"<code>Bloc</code>","text":"<p>             Bases: <code>Election</code></p> <p>Elects m candidates with the highest m-approval scores. The m-approval score of a candidate is equal to the number of voters who rank this candidate among their m top ranked candidates.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on</p> <p><code>seats</code> :   number of seats to be elected</p> <p><code>ballot_ties</code> :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties</p> <p><code>tiebreak</code> :   (Optional) resolves procedural and final ties by specified tiebreak</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class Bloc(Election):\n    \"\"\"\n    Elects m candidates with the highest m-approval scores. The m-approval\n    score of a candidate is equal to the number of voters who rank this\n    candidate among their m top ranked candidates.\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on\n\n    `seats`\n    :   number of seats to be elected\n\n    `ballot_ties`\n    :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties\n\n    `tiebreak`\n    :   (Optional) resolves procedural and final ties by specified tiebreak\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        ballot_ties: bool = True,\n        tiebreak: str = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.tiebreak = tiebreak\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Conducts a Limited election to elect m-candidates\n\n        Returns:\n           An ElectionState object for a Limited election\n        \"\"\"\n        limited_equivalent = Limited(\n            profile=self.state.profile,\n            seats=self.seats,\n            k=self.seats,\n            tiebreak=self.tiebreak,\n        )\n        outcome = limited_equivalent.run_election()\n        self.state = outcome\n        return outcome\n\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Runs complete Bloc election\n\n        Returns:\n            An ElectionState object with results for a complete election\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Bloc.run_election","title":"<code>run_election()</code>","text":"<p>Runs complete Bloc election</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object with results for a complete election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Runs complete Bloc election\n\n    Returns:\n        An ElectionState object with results for a complete election\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Bloc.run_step","title":"<code>run_step()</code>","text":"<p>Conducts a Limited election to elect m-candidates</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a Limited election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Conducts a Limited election to elect m-candidates\n\n    Returns:\n       An ElectionState object for a Limited election\n    \"\"\"\n    limited_equivalent = Limited(\n        profile=self.state.profile,\n        seats=self.seats,\n        k=self.seats,\n        tiebreak=self.tiebreak,\n    )\n    outcome = limited_equivalent.run_election()\n    self.state = outcome\n    return outcome\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Borda","title":"<code>Borda</code>","text":"<p>             Bases: <code>Election</code></p> <p>Positional voting system that assigns a decreasing number of points to candidates based on order and a score vector. The conventional score vector is linear (n, n-1, ... 1)</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on</p> <p><code>seats</code> :   number of seats to be elected</p> <p><code>score_vector</code> :   (Optional) weights assigned to candidate ranking</p> <p><code>ballot_ties</code> :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties</p> <p><code>tiebreak</code> :   (Optional) resolves procedural and final ties by specified tiebreak</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class Borda(Election):\n    \"\"\"\n    Positional voting system that assigns a decreasing number of points to\n    candidates based on order and a score vector. The conventional score\n    vector is linear (n, n-1, ... 1)\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on\n\n    `seats`\n    :   number of seats to be elected\n\n    `score_vector`\n    :   (Optional) weights assigned to candidate ranking\n\n    `ballot_ties`\n    :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties\n\n    `tiebreak`\n    :   (Optional) resolves procedural and final ties by specified tiebreak\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        score_vector: Optional[list[Fraction]],\n        ballot_ties: bool = True,\n        tiebreak: str = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.tiebreak = tiebreak\n        self.score_vector = score_vector\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete Borda contest as Borda is not a round-by-round\n        system\n\n        Returns:\n            An ElectionState object for a complete election\n        \"\"\"\n        borda_dict = borda_scores(\n            profile=self.state.profile, score_vector=self.score_vector\n        )\n\n        ranking = scores_into_set_list(borda_dict)\n        ranking = tie_broken_ranking(\n            ranking=ranking, profile=self.state.profile, tiebreak=self.tiebreak\n        )\n\n        elected, eliminated = elect_cands_from_set_ranking(\n            ranking=ranking, seats=self.seats\n        )\n\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=elected,\n            eliminated=eliminated,\n            remaining=list(),\n            profile=PreferenceProfile(),\n            previous=self.state,\n        )\n        self.state = new_state\n        return new_state\n\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete Borda contest\n\n        Returns:\n            An ElectionState object for a complete election\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Borda.run_election","title":"<code>run_election()</code>","text":"<p>Simulates a complete Borda contest</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete Borda contest\n\n    Returns:\n        An ElectionState object for a complete election\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Borda.run_step","title":"<code>run_step()</code>","text":"<p>Simulates a complete Borda contest as Borda is not a round-by-round system</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete Borda contest as Borda is not a round-by-round\n    system\n\n    Returns:\n        An ElectionState object for a complete election\n    \"\"\"\n    borda_dict = borda_scores(\n        profile=self.state.profile, score_vector=self.score_vector\n    )\n\n    ranking = scores_into_set_list(borda_dict)\n    ranking = tie_broken_ranking(\n        ranking=ranking, profile=self.state.profile, tiebreak=self.tiebreak\n    )\n\n    elected, eliminated = elect_cands_from_set_ranking(\n        ranking=ranking, seats=self.seats\n    )\n\n    new_state = ElectionState(\n        curr_round=self.state.curr_round + 1,\n        elected=elected,\n        eliminated=eliminated,\n        remaining=list(),\n        profile=PreferenceProfile(),\n        previous=self.state,\n    )\n    self.state = new_state\n    return new_state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.CondoBorda","title":"<code>CondoBorda</code>","text":"<p>             Bases: <code>Election</code></p> <p>Elects candidates ordered by dominating set, but breaks ties between candidates with Borda</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on</p> <p><code>seats</code> :   number of seats to be elected</p> <p><code>ballot_ties</code> :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties</p> <p><code>tiebreak</code> :   (Optional) resolves procedural and final ties by specified tiebreak</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class CondoBorda(Election):\n    \"\"\"\n    Elects candidates ordered by dominating set, but breaks ties\n    between candidates with Borda\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on\n\n    `seats`\n    :   number of seats to be elected\n\n    `ballot_ties`\n    :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties\n\n    `tiebreak`\n    :   (Optional) resolves procedural and final ties by specified tiebreak\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        ballot_ties: bool = True,\n        tiebreak: str = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.tiebreak = tiebreak\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Conducts a complete Conda-Borda election as it is not a round-by-round\n        system\n\n        Returns:\n            An `ElectionState` object for a complete election\n        \"\"\"\n        pwc_graph = PairwiseComparisonGraph(self.state.profile)\n        dominating_tiers = pwc_graph.dominating_tiers()\n        ranking = tie_broken_ranking(\n            ranking=dominating_tiers, profile=self.state.profile, tiebreak=\"borda\"\n        )\n        elected, eliminated = elect_cands_from_set_ranking(\n            ranking=ranking, seats=self.seats\n        )\n\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=elected,\n            eliminated=eliminated,\n            remaining=list(),\n            profile=PreferenceProfile(),\n            previous=self.state,\n        )\n        self.state = new_state\n        return new_state\n\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete Conda-Borda election\n\n        Returns:\n            An ElectionState object for a complete election\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.CondoBorda.run_election","title":"<code>run_election()</code>","text":"<p>Simulates a complete Conda-Borda election</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete Conda-Borda election\n\n    Returns:\n        An ElectionState object for a complete election\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.CondoBorda.run_step","title":"<code>run_step()</code>","text":"<p>Conducts a complete Conda-Borda election as it is not a round-by-round system</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An <code>ElectionState</code> object for a complete election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Conducts a complete Conda-Borda election as it is not a round-by-round\n    system\n\n    Returns:\n        An `ElectionState` object for a complete election\n    \"\"\"\n    pwc_graph = PairwiseComparisonGraph(self.state.profile)\n    dominating_tiers = pwc_graph.dominating_tiers()\n    ranking = tie_broken_ranking(\n        ranking=dominating_tiers, profile=self.state.profile, tiebreak=\"borda\"\n    )\n    elected, eliminated = elect_cands_from_set_ranking(\n        ranking=ranking, seats=self.seats\n    )\n\n    new_state = ElectionState(\n        curr_round=self.state.curr_round + 1,\n        elected=elected,\n        eliminated=eliminated,\n        remaining=list(),\n        profile=PreferenceProfile(),\n        previous=self.state,\n    )\n    self.state = new_state\n    return new_state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.DominatingSets","title":"<code>DominatingSets</code>","text":"<p>             Bases: <code>Election</code></p> <p>Finds tiers of candidates by dominating set,which is a set of candidates such that every candidate in the set wins head to head comparisons against candidates outside of it</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on</p> <p><code>ballot_ties</code> :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class DominatingSets(Election):\n    \"\"\"\n    Finds tiers of candidates by dominating set,which is a set of candidates\n    such that every candidate in the set wins head to head comparisons against\n    candidates outside of it\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on\n\n    `ballot_ties`\n    :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties\n\n\n    **Methods**\n    \"\"\"\n\n    def __init__(self, profile: PreferenceProfile, ballot_ties: bool = True):\n        super().__init__(profile, ballot_ties)\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Conducts a complete DominatingSets election as it is not a round-by-round\n        system\n\n        Returns:\n            An ElectionState object for a complete election\n        \"\"\"\n        pwc_graph = PairwiseComparisonGraph(self.state.profile)\n        dominating_tiers = pwc_graph.dominating_tiers()\n        if len(dominating_tiers) == 1:\n            new_state = ElectionState(\n                curr_round=self.state.curr_round + 1,\n                elected=list(),\n                eliminated=dominating_tiers,\n                remaining=list(),\n                profile=PreferenceProfile(),\n                previous=self.state,\n            )\n        else:\n            new_state = ElectionState(\n                curr_round=self.state.curr_round + 1,\n                elected=[set(dominating_tiers[0])],\n                eliminated=dominating_tiers[1:],\n                remaining=list(),\n                profile=PreferenceProfile(),\n                previous=self.state,\n            )\n        self.state = new_state\n        return new_state\n\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete DominatingSets election\n\n        Returns:\n            An ElectionState object for a complete election\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.DominatingSets.run_election","title":"<code>run_election()</code>","text":"<p>Simulates a complete DominatingSets election</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete DominatingSets election\n\n    Returns:\n        An ElectionState object for a complete election\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.DominatingSets.run_step","title":"<code>run_step()</code>","text":"<p>Conducts a complete DominatingSets election as it is not a round-by-round system</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Conducts a complete DominatingSets election as it is not a round-by-round\n    system\n\n    Returns:\n        An ElectionState object for a complete election\n    \"\"\"\n    pwc_graph = PairwiseComparisonGraph(self.state.profile)\n    dominating_tiers = pwc_graph.dominating_tiers()\n    if len(dominating_tiers) == 1:\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=list(),\n            eliminated=dominating_tiers,\n            remaining=list(),\n            profile=PreferenceProfile(),\n            previous=self.state,\n        )\n    else:\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=[set(dominating_tiers[0])],\n            eliminated=dominating_tiers[1:],\n            remaining=list(),\n            profile=PreferenceProfile(),\n            previous=self.state,\n        )\n    self.state = new_state\n    return new_state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Limited","title":"<code>Limited</code>","text":"<p>             Bases: <code>Election</code></p> <p>Elects m (seats) candidates with the highest k-approval scores. The k-approval score of a candidate is equal to the number of voters who </p> <p>rank this candidate among their k top ranked candidates.</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on</p> <p><code>k</code> :   value of an approval score</p> <p><code>seats</code> :   number of seats to be elected</p> <p><code>ballot_ties</code> :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties</p> <p><code>tiebreak</code> :   (Optional) resolves procedural and final ties by specified tiebreak</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class Limited(Election):\n    \"\"\"\n    Elects m (seats) candidates with the highest k-approval scores.\n    The k-approval score of a candidate is equal to the number of voters who \\n\n    rank this candidate among their k top ranked candidates.\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on\n\n    `k`\n    :   value of an approval score\n\n    `seats`\n    :   number of seats to be elected\n\n    `ballot_ties`\n    :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties\n\n    `tiebreak`\n    :   (Optional) resolves procedural and final ties by specified tiebreak\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        k: int,\n        ballot_ties: bool = True,\n        tiebreak: str = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.k = k\n        self.tiebreak = tiebreak\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Conducts Limited election in which m-candidates are elected based\n        on approval scores\n\n        Returns:\n           An ElectionState object for a Limited election\n        \"\"\"\n        profile = self.state.profile\n        candidates = profile.get_candidates()\n        candidate_approvals = {c: Fraction(0) for c in candidates}\n\n        for ballot in profile.get_ballots():\n            # First we have to determine which candidates are approved\n            # i.e. in first k ranks on a ballot\n            approvals = []\n            for i, cand_set in enumerate(ballot.ranking):\n                # If list of total candidates before and including current set\n                # are less than seat count, all candidates are approved\n                if len(list(it.chain(*ballot.ranking[: i + 1]))) &lt; self.k:\n                    approvals.extend(list(cand_set))\n                # If list of total candidates before current set\n                # are greater than seat count, no candidates are approved\n                elif len(list(it.chain(*ballot.ranking[:i]))) &gt; self.k:\n                    approvals.extend([])\n                # Else we know the cutoff is in the set, we compute and randomly\n                # select the number of candidates we can select\n                else:\n                    accepted = len(list(it.chain(*ballot.ranking[:i])))\n                    num_to_allow = self.k - accepted\n                    approvals.extend(\n                        np.random.choice(list(cand_set), num_to_allow, replace=False)\n                    )\n\n            # Add approval votes equal to ballot weight (i.e. number of voters with this ballot)\n            for cand in approvals:\n                candidate_approvals[cand] += ballot.weight\n\n        # Order candidates by number of approval votes received\n        ranking = scores_into_set_list(candidate_approvals)\n        ranking = tie_broken_ranking(\n            ranking=ranking, profile=self.state.profile, tiebreak=self.tiebreak\n        )\n        elected, eliminated = elect_cands_from_set_ranking(\n            ranking=ranking, seats=self.seats\n        )\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=elected,\n            eliminated=eliminated,\n            remaining=list(),\n            profile=PreferenceProfile(),\n            previous=self.state,\n        )\n        self.state = new_state\n        return self.state\n\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete Limited election\n\n        Returns:\n            An ElectionState object with results for a complete election\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Limited.run_election","title":"<code>run_election()</code>","text":"<p>Simulates a complete Limited election</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object with results for a complete election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete Limited election\n\n    Returns:\n        An ElectionState object with results for a complete election\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Limited.run_step","title":"<code>run_step()</code>","text":"<p>Conducts Limited election in which m-candidates are elected based on approval scores</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a Limited election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Conducts Limited election in which m-candidates are elected based\n    on approval scores\n\n    Returns:\n       An ElectionState object for a Limited election\n    \"\"\"\n    profile = self.state.profile\n    candidates = profile.get_candidates()\n    candidate_approvals = {c: Fraction(0) for c in candidates}\n\n    for ballot in profile.get_ballots():\n        # First we have to determine which candidates are approved\n        # i.e. in first k ranks on a ballot\n        approvals = []\n        for i, cand_set in enumerate(ballot.ranking):\n            # If list of total candidates before and including current set\n            # are less than seat count, all candidates are approved\n            if len(list(it.chain(*ballot.ranking[: i + 1]))) &lt; self.k:\n                approvals.extend(list(cand_set))\n            # If list of total candidates before current set\n            # are greater than seat count, no candidates are approved\n            elif len(list(it.chain(*ballot.ranking[:i]))) &gt; self.k:\n                approvals.extend([])\n            # Else we know the cutoff is in the set, we compute and randomly\n            # select the number of candidates we can select\n            else:\n                accepted = len(list(it.chain(*ballot.ranking[:i])))\n                num_to_allow = self.k - accepted\n                approvals.extend(\n                    np.random.choice(list(cand_set), num_to_allow, replace=False)\n                )\n\n        # Add approval votes equal to ballot weight (i.e. number of voters with this ballot)\n        for cand in approvals:\n            candidate_approvals[cand] += ballot.weight\n\n    # Order candidates by number of approval votes received\n    ranking = scores_into_set_list(candidate_approvals)\n    ranking = tie_broken_ranking(\n        ranking=ranking, profile=self.state.profile, tiebreak=self.tiebreak\n    )\n    elected, eliminated = elect_cands_from_set_ranking(\n        ranking=ranking, seats=self.seats\n    )\n    new_state = ElectionState(\n        curr_round=self.state.curr_round + 1,\n        elected=elected,\n        eliminated=eliminated,\n        remaining=list(),\n        profile=PreferenceProfile(),\n        previous=self.state,\n    )\n    self.state = new_state\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.Plurality","title":"<code>Plurality</code>","text":"<p>             Bases: <code>SNTV</code></p> <p>Simulates a single or multi-winner plurality election. Inherits methods from <code>SNTV</code> to run election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class Plurality(SNTV):\n    \"\"\"\n    Simulates a single or multi-winner plurality election. Inherits\n    methods from `SNTV` to run election\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        ballot_ties: bool = True,\n        tiebreak: str = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.tiebreak = tiebreak\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SNTV","title":"<code>SNTV</code>","text":"<p>             Bases: <code>Election</code></p> <p>Single nontransferable vote (SNTV): Elects k-candidates with the highest Plurality scores</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on</p> <p><code>seats</code> :   number of seats to be elected</p> <p><code>ballot_ties</code> :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties</p> <p><code>tiebreak</code> :   (Optional) resolves procedural and final ties by specified tiebreak</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class SNTV(Election):\n    \"\"\"\n    Single nontransferable vote (SNTV): Elects k-candidates with the highest\n    Plurality scores\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on\n\n    `seats`\n    :   number of seats to be elected\n\n    `ballot_ties`\n    :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties\n\n    `tiebreak`\n    :   (Optional) resolves procedural and final ties by specified tiebreak\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        ballot_ties: bool = True,\n        tiebreak: str = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.tiebreak = tiebreak\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Conducts a Limited election to elect k-candidates\n\n        Returns:\n           An ElectionState object for a Limited election\n        \"\"\"\n        limited_equivalent = Limited(\n            profile=self.state.profile, seats=self.seats, k=1, tiebreak=self.tiebreak\n        )\n        outcome = limited_equivalent.run_election()\n        self.state = outcome\n        return outcome\n\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Runs complete SNTV election\n\n        Returns:\n            An ElectionState object with results for a complete election\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SNTV.run_election","title":"<code>run_election()</code>","text":"<p>Runs complete SNTV election</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object with results for a complete election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Runs complete SNTV election\n\n    Returns:\n        An ElectionState object with results for a complete election\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SNTV.run_step","title":"<code>run_step()</code>","text":"<p>Conducts a Limited election to elect k-candidates</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a Limited election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Conducts a Limited election to elect k-candidates\n\n    Returns:\n       An ElectionState object for a Limited election\n    \"\"\"\n    limited_equivalent = Limited(\n        profile=self.state.profile, seats=self.seats, k=1, tiebreak=self.tiebreak\n    )\n    outcome = limited_equivalent.run_election()\n    self.state = outcome\n    return outcome\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SNTV_STV_Hybrid","title":"<code>SNTV_STV_Hybrid</code>","text":"<p>             Bases: <code>Election</code></p> <p>Election methd that first runs SNTV to a cutoff, then runs STV to pick a committee with a given number of seats</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on</p> <p><code>transfer</code> :   transfer method (e.g. fractional transfer)</p> <p><code>r1_cutoff</code> :   first-round cutoff value</p> <p><code>seats</code> :   number of seats to be elected</p> <p><code>ballot_ties</code> :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties</p> <p><code>tiebreak</code> :   (Optional) resolves procedural and final ties by specified tiebreak</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class SNTV_STV_Hybrid(Election):\n    \"\"\"\n    Election methd that first runs SNTV to a cutoff, then runs STV to\n    pick a committee with a given number of seats\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on\n\n    `transfer`\n    :   transfer method (e.g. fractional transfer)\n\n    `r1_cutoff`\n    :   first-round cutoff value\n\n    `seats`\n    :   number of seats to be elected\n\n    `ballot_ties`\n    :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties\n\n    `tiebreak`\n    :   (Optional) resolves procedural and final ties by specified tiebreak\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        transfer: Callable,\n        r1_cutoff: int,\n        seats: int,\n        ballot_ties: bool = True,\n        tiebreak: str = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.transfer = transfer\n        self.r1_cutoff = r1_cutoff\n        self.seats = seats\n        self.tiebreak = tiebreak\n        self.stage = \"SNTV\"  # SNTV, switches to STV, then Complete\n\n    def run_step(self, stage: str) -&gt; ElectionState:\n        \"\"\"\n        Simulates one round an SNTV_STV election\n\n        Args:\n            stage: Stage of the hybrid election, can be SNTV or STV\n\n        Returns:\n           An ElectionState object for a given round\n        \"\"\"\n        profile = self.state.profile\n\n        new_state = None\n        if stage == \"SNTV\":\n            round_state = SNTV(\n                profile=profile, seats=self.r1_cutoff, tiebreak=self.tiebreak\n            ).run_election()\n\n            # The STV election will be run on the new election state\n            # Therefore we should not add any winners, but rather\n            # set the SNTV winners as remaining candidates and update pref profiles\n            new_profile = PreferenceProfile(\n                ballots=remove_cand(\n                    set().union(*round_state.eliminated), profile.get_ballots()\n                )\n            )\n            new_state = ElectionState(\n                curr_round=self.state.curr_round + 1,\n                elected=list(),\n                eliminated=round_state.eliminated,\n                remaining=[set(new_profile.get_candidates())],\n                profile=new_profile,\n                previous=self.state,\n            )\n        elif stage == \"STV\":\n            round_state = STV(\n                profile=profile,\n                transfer=self.transfer,\n                seats=self.seats,\n                tiebreak=self.tiebreak,\n            ).run_election()\n\n            new_state = ElectionState(\n                curr_round=self.state.curr_round + 1,\n                elected=round_state.get_all_winners(),\n                eliminated=round_state.get_all_eliminated(),\n                remaining=round_state.remaining,\n                profile=round_state.profile,\n                previous=self.state,\n            )\n\n        # Update election stage to cue next run step\n        if stage == \"SNTV\":\n            self.stage = \"STV\"\n        elif stage == \"STV\":\n            self.stage = \"Complete\"\n\n        self.state = new_state  # type: ignore\n        return new_state  # type: ignore\n\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Runs complete SNTV_STV election\n\n        Returns:\n            An ElectionState object with results for a complete election\n        \"\"\"\n        while self.stage != \"Complete\":\n            self.run_step(self.stage)\n        return self.state  # type: ignore\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SNTV_STV_Hybrid.run_election","title":"<code>run_election()</code>","text":"<p>Runs complete SNTV_STV election</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object with results for a complete election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Runs complete SNTV_STV election\n\n    Returns:\n        An ElectionState object with results for a complete election\n    \"\"\"\n    while self.stage != \"Complete\":\n        self.run_step(self.stage)\n    return self.state  # type: ignore\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SNTV_STV_Hybrid.run_step","title":"<code>run_step(stage)</code>","text":"<p>Simulates one round an SNTV_STV election</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>str</code> <p>Stage of the hybrid election, can be SNTV or STV</p> required <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a given round</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self, stage: str) -&gt; ElectionState:\n    \"\"\"\n    Simulates one round an SNTV_STV election\n\n    Args:\n        stage: Stage of the hybrid election, can be SNTV or STV\n\n    Returns:\n       An ElectionState object for a given round\n    \"\"\"\n    profile = self.state.profile\n\n    new_state = None\n    if stage == \"SNTV\":\n        round_state = SNTV(\n            profile=profile, seats=self.r1_cutoff, tiebreak=self.tiebreak\n        ).run_election()\n\n        # The STV election will be run on the new election state\n        # Therefore we should not add any winners, but rather\n        # set the SNTV winners as remaining candidates and update pref profiles\n        new_profile = PreferenceProfile(\n            ballots=remove_cand(\n                set().union(*round_state.eliminated), profile.get_ballots()\n            )\n        )\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=list(),\n            eliminated=round_state.eliminated,\n            remaining=[set(new_profile.get_candidates())],\n            profile=new_profile,\n            previous=self.state,\n        )\n    elif stage == \"STV\":\n        round_state = STV(\n            profile=profile,\n            transfer=self.transfer,\n            seats=self.seats,\n            tiebreak=self.tiebreak,\n        ).run_election()\n\n        new_state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=round_state.get_all_winners(),\n            eliminated=round_state.get_all_eliminated(),\n            remaining=round_state.remaining,\n            profile=round_state.profile,\n            previous=self.state,\n        )\n\n    # Update election stage to cue next run step\n    if stage == \"SNTV\":\n        self.stage = \"STV\"\n    elif stage == \"STV\":\n        self.stage = \"Complete\"\n\n    self.state = new_state  # type: ignore\n    return new_state  # type: ignore\n</code></pre>"},{"location":"api/#votekit.elections.election_types.STV","title":"<code>STV</code>","text":"<p>             Bases: <code>Election</code></p> <p>Class for single-winner IRV and multi-winner STV elections</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on</p> <p><code>transfer</code> :   transfer method (e.g. fractional transfer)</p> <p><code>seats</code> :   number of seats to be elected</p> <p><code>quota</code> :   formula to calculate quota (defaults to droop)</p> <p><code>ballot_ties</code> :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties</p> <p><code>tiebreak</code> :   (Optional) resolves procedural and final ties by specified tiebreak</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class STV(Election):\n    \"\"\"\n    Class for single-winner IRV and multi-winner STV elections\n\n     **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on\n\n    `transfer`\n    :   transfer method (e.g. fractional transfer)\n\n    `seats`\n    :   number of seats to be elected\n\n    `quota`\n    :   formula to calculate quota (defaults to droop)\n\n    `ballot_ties`\n    :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties\n\n    `tiebreak`\n    :   (Optional) resolves procedural and final ties by specified tiebreak\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        transfer: Callable,\n        seats: int,\n        quota: str = \"droop\",\n        ballot_ties: bool = True,\n        tiebreak: str = \"random\",\n    ):\n        # let parent class handle the og profile and election state\n        super().__init__(profile, ballot_ties)\n\n        self.transfer = transfer\n        self.seats = seats\n        self.tiebreak = tiebreak\n        self.quota = quota.lower()\n        self.threshold = self.get_threshold()\n\n    # can cache since it will not change throughout rounds\n    def get_threshold(self) -&gt; int:\n        \"\"\"\n        Calculates threshold required for election\n\n        Returns:\n            Value of the threshold\n        \"\"\"\n        quota = self.quota\n        if quota == \"droop\":\n            return int(self._profile.num_ballots() / (self.seats + 1) + 1)\n        elif quota == \"hare\":\n            return int(self._profile.num_ballots() / self.seats)\n        else:\n            raise ValueError(\"Misspelled or unknown quota type\")\n\n    def next_round(self) -&gt; bool:\n        \"\"\"\n        Determines if the number of seats has been met to call an election\n\n        Returns:\n            True if number of seats has been met, False otherwise\n        \"\"\"\n        cands_elected = 0\n        for s in self.state.get_all_winners():\n            cands_elected += len(s)\n        return cands_elected &lt; self.seats\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates one round an STV election\n\n        Returns:\n           An ElectionState object for a given round\n        \"\"\"\n        remaining = self.state.profile.get_candidates()\n        ballots = self.state.profile.get_ballots()\n        round_votes = compute_votes(remaining, ballots)\n        elected = []\n        eliminated = []\n\n        # if number of remaining candidates equals number of remaining seats,\n        # everyone is elected\n        if len(remaining) == self.seats - len(self.state.get_all_winners()):\n            elected = [{cand} for cand, votes in round_votes]\n            remaining = []\n            ballots = []\n\n        # elect all candidates who crossed threshold\n        elif round_votes[0].votes &gt;= self.threshold:\n            for candidate, votes in round_votes:\n                if votes &gt;= self.threshold:\n                    elected.append({candidate})\n                    remaining.remove(candidate)\n                    ballots = self.transfer(\n                        candidate,\n                        ballots,\n                        {cand: votes for cand, votes in round_votes},\n                        self.threshold,\n                    )\n        # since no one has crossed threshold, eliminate one of the people\n        # with least first place votes\n        elif self.next_round():\n            lp_candidates = [\n                candidate\n                for candidate, votes in round_votes\n                if votes == round_votes[-1].votes\n            ]\n\n            lp_cand = tie_broken_ranking(\n                ranking=[set(lp_candidates)],\n                profile=self.state.profile,\n                tiebreak=self.tiebreak,\n            )[-1]\n            eliminated.append(lp_cand)\n            ballots = remove_cand(lp_cand, ballots)\n            remaining.remove(next(iter(lp_cand)))\n\n        if len(elected) &gt;= 1:\n            elected = scores_into_set_list(\n                first_place_votes(self.state.profile), [c for s in elected for c in s]\n            )\n\n        # Make sure list-of-sets have non-empty elements\n        elected = [s for s in elected if s != set()]\n        eliminated = [s for s in eliminated if s != set()]\n\n        remaining = [set(remaining)]\n        remaining = [s for s in remaining if s != set()]\n\n        self.state = ElectionState(\n            curr_round=self.state.curr_round + 1,\n            elected=elected,\n            eliminated=eliminated,\n            remaining=remaining,\n            profile=PreferenceProfile(ballots=ballots),\n            previous=self.state,\n        )\n        return self.state\n\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Runs complete STV election\n\n        Returns:\n            An ElectionState object with results for a complete election\n        \"\"\"\n        if not self.next_round():\n            raise ValueError(\n                f\"Length of elected set equal to number of seats ({self.seats})\"\n            )\n\n        while self.next_round():\n            self.run_step()\n\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.STV.get_threshold","title":"<code>get_threshold()</code>","text":"<p>Calculates threshold required for election</p> <p>Returns:</p> Type Description <code>int</code> <p>Value of the threshold</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def get_threshold(self) -&gt; int:\n    \"\"\"\n    Calculates threshold required for election\n\n    Returns:\n        Value of the threshold\n    \"\"\"\n    quota = self.quota\n    if quota == \"droop\":\n        return int(self._profile.num_ballots() / (self.seats + 1) + 1)\n    elif quota == \"hare\":\n        return int(self._profile.num_ballots() / self.seats)\n    else:\n        raise ValueError(\"Misspelled or unknown quota type\")\n</code></pre>"},{"location":"api/#votekit.elections.election_types.STV.next_round","title":"<code>next_round()</code>","text":"<p>Determines if the number of seats has been met to call an election</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if number of seats has been met, False otherwise</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def next_round(self) -&gt; bool:\n    \"\"\"\n    Determines if the number of seats has been met to call an election\n\n    Returns:\n        True if number of seats has been met, False otherwise\n    \"\"\"\n    cands_elected = 0\n    for s in self.state.get_all_winners():\n        cands_elected += len(s)\n    return cands_elected &lt; self.seats\n</code></pre>"},{"location":"api/#votekit.elections.election_types.STV.run_election","title":"<code>run_election()</code>","text":"<p>Runs complete STV election</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object with results for a complete election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Runs complete STV election\n\n    Returns:\n        An ElectionState object with results for a complete election\n    \"\"\"\n    if not self.next_round():\n        raise ValueError(\n            f\"Length of elected set equal to number of seats ({self.seats})\"\n        )\n\n    while self.next_round():\n        self.run_step()\n\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.STV.run_step","title":"<code>run_step()</code>","text":"<p>Simulates one round an STV election</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a given round</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates one round an STV election\n\n    Returns:\n       An ElectionState object for a given round\n    \"\"\"\n    remaining = self.state.profile.get_candidates()\n    ballots = self.state.profile.get_ballots()\n    round_votes = compute_votes(remaining, ballots)\n    elected = []\n    eliminated = []\n\n    # if number of remaining candidates equals number of remaining seats,\n    # everyone is elected\n    if len(remaining) == self.seats - len(self.state.get_all_winners()):\n        elected = [{cand} for cand, votes in round_votes]\n        remaining = []\n        ballots = []\n\n    # elect all candidates who crossed threshold\n    elif round_votes[0].votes &gt;= self.threshold:\n        for candidate, votes in round_votes:\n            if votes &gt;= self.threshold:\n                elected.append({candidate})\n                remaining.remove(candidate)\n                ballots = self.transfer(\n                    candidate,\n                    ballots,\n                    {cand: votes for cand, votes in round_votes},\n                    self.threshold,\n                )\n    # since no one has crossed threshold, eliminate one of the people\n    # with least first place votes\n    elif self.next_round():\n        lp_candidates = [\n            candidate\n            for candidate, votes in round_votes\n            if votes == round_votes[-1].votes\n        ]\n\n        lp_cand = tie_broken_ranking(\n            ranking=[set(lp_candidates)],\n            profile=self.state.profile,\n            tiebreak=self.tiebreak,\n        )[-1]\n        eliminated.append(lp_cand)\n        ballots = remove_cand(lp_cand, ballots)\n        remaining.remove(next(iter(lp_cand)))\n\n    if len(elected) &gt;= 1:\n        elected = scores_into_set_list(\n            first_place_votes(self.state.profile), [c for s in elected for c in s]\n        )\n\n    # Make sure list-of-sets have non-empty elements\n    elected = [s for s in elected if s != set()]\n    eliminated = [s for s in eliminated if s != set()]\n\n    remaining = [set(remaining)]\n    remaining = [s for s in remaining if s != set()]\n\n    self.state = ElectionState(\n        curr_round=self.state.curr_round + 1,\n        elected=elected,\n        eliminated=eliminated,\n        remaining=remaining,\n        profile=PreferenceProfile(ballots=ballots),\n        previous=self.state,\n    )\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SequentialRCV","title":"<code>SequentialRCV</code>","text":"<p>             Bases: <code>Election</code></p> <p>Class to conduct Sequential RCV election, in which votes are not transferred after a candidate has reached threshold, or been elected</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on</p> <p><code>seats</code> :   number of seats to be elected</p> <p><code>ballot_ties</code> :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties</p> <p><code>tiebreak</code> :   (Optional) resolves procedural and final ties by specified tiebreak</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class SequentialRCV(Election):\n    \"\"\"\n    Class to conduct Sequential RCV election, in which votes are not transferred\n    after a candidate has reached threshold, or been elected\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on\n\n    `seats`\n    :   number of seats to be elected\n\n    `ballot_ties`\n    :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties\n\n    `tiebreak`\n    :   (Optional) resolves procedural and final ties by specified tiebreak\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        seats: int,\n        ballot_ties: bool = True,\n        tiebreak: str = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.seats = seats\n        self.tiebreak = tiebreak\n\n    def run_step(self, old_profile: PreferenceProfile) -&gt; ElectionState:\n        \"\"\"\n        Simulates a single step of the sequential RCV contest or a full\n        IRV election run on the current set of candidates\n\n         Returns:\n           An ElectionState object for a given round\n        \"\"\"\n        old_election_state = self.state\n\n        IRVrun = STV(\n            old_profile, transfer=seqRCV_transfer, seats=1, tiebreak=self.tiebreak\n        )\n        old_election = IRVrun.run_election()\n        elected_cand = old_election.get_all_winners()[0]\n\n        # Removes elected candidate from Ballot List\n        updated_ballots = remove_cand(elected_cand, old_profile.get_ballots())\n\n        # Updates profile with removed candidates\n        updated_profile = PreferenceProfile(ballots=updated_ballots)\n\n        self.state = ElectionState(\n            curr_round=old_election_state.curr_round + 1,\n            elected=[elected_cand],\n            profile=updated_profile,\n            previous=old_election_state,\n            remaining=old_election.remaining,\n        )\n        return self.state\n\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete sequential RCV contest.\n\n        Returns:\n            An ElectionState object for a complete election\n        \"\"\"\n        old_profile = self._profile\n        elected = []  # type: ignore\n        seqRCV_step = self.state\n\n        while len(elected) &lt; self.seats:\n            seqRCV_step = self.run_step(old_profile)\n            elected.append(seqRCV_step.elected)\n            old_profile = seqRCV_step.profile\n        return seqRCV_step\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SequentialRCV.run_election","title":"<code>run_election()</code>","text":"<p>Simulates a complete sequential RCV contest.</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete sequential RCV contest.\n\n    Returns:\n        An ElectionState object for a complete election\n    \"\"\"\n    old_profile = self._profile\n    elected = []  # type: ignore\n    seqRCV_step = self.state\n\n    while len(elected) &lt; self.seats:\n        seqRCV_step = self.run_step(old_profile)\n        elected.append(seqRCV_step.elected)\n        old_profile = seqRCV_step.profile\n    return seqRCV_step\n</code></pre>"},{"location":"api/#votekit.elections.election_types.SequentialRCV.run_step","title":"<code>run_step(old_profile)</code>","text":"<p>Simulates a single step of the sequential RCV contest or a full IRV election run on the current set of candidates</p> <p>Returns:    An ElectionState object for a given round</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self, old_profile: PreferenceProfile) -&gt; ElectionState:\n    \"\"\"\n    Simulates a single step of the sequential RCV contest or a full\n    IRV election run on the current set of candidates\n\n     Returns:\n       An ElectionState object for a given round\n    \"\"\"\n    old_election_state = self.state\n\n    IRVrun = STV(\n        old_profile, transfer=seqRCV_transfer, seats=1, tiebreak=self.tiebreak\n    )\n    old_election = IRVrun.run_election()\n    elected_cand = old_election.get_all_winners()[0]\n\n    # Removes elected candidate from Ballot List\n    updated_ballots = remove_cand(elected_cand, old_profile.get_ballots())\n\n    # Updates profile with removed candidates\n    updated_profile = PreferenceProfile(ballots=updated_ballots)\n\n    self.state = ElectionState(\n        curr_round=old_election_state.curr_round + 1,\n        elected=[elected_cand],\n        profile=updated_profile,\n        previous=old_election_state,\n        remaining=old_election.remaining,\n    )\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.TopTwo","title":"<code>TopTwo</code>","text":"<p>             Bases: <code>Election</code></p> <p>Eliminates all but the top two plurality vote getters, and then conducts a runoff between them, reallocating other ballots</p> <p>Attributes</p> <p><code>profile</code> :   PreferenceProfile to run election on</p> <p><code>seats</code> :   number of seats to be elected</p> <p><code>ballot_ties</code> :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties</p> <p><code>tiebreak</code> :   (Optional) resolves procedural and final ties by specified tiebreak</p> <p>Methods</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>class TopTwo(Election):\n    \"\"\"\n    Eliminates all but the top two plurality vote getters, and then\n    conducts a runoff between them, reallocating other ballots\n\n    **Attributes**\n\n    `profile`\n    :   PreferenceProfile to run election on\n\n    `seats`\n    :   number of seats to be elected\n\n    `ballot_ties`\n    :   (Optional) resolves input ballot ties if True, else assumes ballots have no ties\n\n    `tiebreak`\n    :   (Optional) resolves procedural and final ties by specified tiebreak\n\n    **Methods**\n    \"\"\"\n\n    def __init__(\n        self,\n        profile: PreferenceProfile,\n        ballot_ties: bool = True,\n        tiebreak: str = \"random\",\n    ):\n        super().__init__(profile, ballot_ties)\n        self.tiebreak = tiebreak\n\n    def run_step(self) -&gt; ElectionState:\n        \"\"\"\n        Conducts a hybrid election for one seat with a cutoff of 2 for the runoff\n\n        Returns:\n            An ElectionState object for the hybrid election\n        \"\"\"\n        hybrid_equivalent = SNTV_STV_Hybrid(\n            profile=self.state.profile,\n            transfer=fractional_transfer,\n            r1_cutoff=2,\n            seats=1,\n            tiebreak=self.tiebreak,\n        )\n        outcome = hybrid_equivalent.run_election()\n        self.state = outcome\n        return outcome\n\n    def run_election(self) -&gt; ElectionState:\n        \"\"\"\n        Simulates a complete TopTwo election\n\n        Returns:\n            An ElectionState object for a complete election\n        \"\"\"\n        self.run_step()\n        return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.TopTwo.run_election","title":"<code>run_election()</code>","text":"<p>Simulates a complete TopTwo election</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for a complete election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_election(self) -&gt; ElectionState:\n    \"\"\"\n    Simulates a complete TopTwo election\n\n    Returns:\n        An ElectionState object for a complete election\n    \"\"\"\n    self.run_step()\n    return self.state\n</code></pre>"},{"location":"api/#votekit.elections.election_types.TopTwo.run_step","title":"<code>run_step()</code>","text":"<p>Conducts a hybrid election for one seat with a cutoff of 2 for the runoff</p> <p>Returns:</p> Type Description <code>ElectionState</code> <p>An ElectionState object for the hybrid election</p> Source code in <code>src/votekit/elections/election_types.py</code> <pre><code>def run_step(self) -&gt; ElectionState:\n    \"\"\"\n    Conducts a hybrid election for one seat with a cutoff of 2 for the runoff\n\n    Returns:\n        An ElectionState object for the hybrid election\n    \"\"\"\n    hybrid_equivalent = SNTV_STV_Hybrid(\n        profile=self.state.profile,\n        transfer=fractional_transfer,\n        r1_cutoff=2,\n        seats=1,\n        tiebreak=self.tiebreak,\n    )\n    outcome = hybrid_equivalent.run_election()\n    self.state = outcome\n    return outcome\n</code></pre>"},{"location":"api/#cleaning","title":"Cleaning","text":""},{"location":"api/#votekit.cleaning.clean_profile","title":"<code>clean_profile(pp, clean_ballot_func)</code>","text":"<p>Allows user-defined cleaning rules for PrefrenceProfile. Input function that applies modification or rule to a single ballot</p> <p>Parameters:</p> Name Type Description Default <code>pp</code> <code>PreferenceProfile</code> <p>a preference profile to clean</p> required <code>clean_ballot_func</code> <code>Callable[[Ballot], Ballot]</code> <p>function that             takes a list of ballots and cleans each ballot</p> required <p>Returns:</p> Name Type Description <code>PreferenceProfile</code> <code>PreferenceProfile</code> <p>a cleaned preference profile</p> Source code in <code>src/votekit/cleaning.py</code> <pre><code>def clean_profile(\n    pp: PreferenceProfile, clean_ballot_func: Callable[[Ballot], Ballot]\n) -&gt; PreferenceProfile:\n    \"\"\"\n    Allows user-defined cleaning rules for PrefrenceProfile. Input function\n    that applies modification or rule to a single ballot\n\n    Args:\n        pp (PreferenceProfile): a preference profile to clean\n        clean_ballot_func (Callable[[Ballot], Ballot]): function that \\\n            takes a list of ballots and cleans each ballot\n\n    Returns:\n        PreferenceProfile: a cleaned preference profile\n    \"\"\"\n\n    # apply cleaning function to clean all ballots\n    if clean_ballot_func is not None:\n        cleaned = map(clean_ballot_func, pp.ballots)\n    # group ballots that have the same ranking after cleaning\n    grouped_ballots = [\n        list(result)\n        for key, result in groupby(cleaned, key=lambda ballot: ballot.ranking)\n    ]\n    # merge ballots in the same groups\n    new_ballots = [merge_ballots(b) for b in grouped_ballots]\n    return PreferenceProfile(ballots=new_ballots)\n</code></pre>"},{"location":"api/#votekit.cleaning.deduplicate_profiles","title":"<code>deduplicate_profiles(pp)</code>","text":"<p>Given a preference profile, deduplicates its ballots.</p> <p>Parameters:</p> Name Type Description Default <code>pp</code> <code>PreferenceProfile</code> <p>a preference profile to clean</p> required <p>Returns:</p> Name Type Description <code>PreferenceProfile</code> <code>PreferenceProfile</code> <p>a cleaned preference profile without duplicates</p> Source code in <code>src/votekit/cleaning.py</code> <pre><code>def deduplicate_profiles(pp: PreferenceProfile) -&gt; PreferenceProfile:\n    \"\"\"\n    Given a preference profile, deduplicates its ballots.\n\n    Args:\n        pp (PreferenceProfile): a preference profile to clean\n\n    Returns:\n        PreferenceProfile: a cleaned preference profile without duplicates\n    \"\"\"\n\n    def deduplicate_ballots(ballot: Ballot) -&gt; Ballot:\n        \"\"\"\n        Takes a ballot and deduplicates its rankings\n\n        Args:\n            ballot (Ballot): a ballot with duplicates in its ranking\n\n        Returns:\n            Ballot: a ballot without duplicates\n        \"\"\"\n        ranking = ballot.ranking\n        dedup_ranking = []\n        for cand in ranking:\n            if cand in ranking and cand not in dedup_ranking:\n                # dedup_ranking.append({None})\n                dedup_ranking.append(cand)\n        new_ballot = Ballot(\n            id=ballot.id,\n            weight=Fraction(ballot.weight),\n            ranking=dedup_ranking,\n            voters=ballot.voters,\n        )\n        return new_ballot\n\n    pp_clean = clean_profile(pp=pp, clean_ballot_func=deduplicate_ballots)\n    return pp_clean\n</code></pre>"},{"location":"api/#votekit.cleaning.merge_ballots","title":"<code>merge_ballots(ballots)</code>","text":"<p>Takes a list of ballots with the same ranking and merge them into one ballot.</p> <p>Parameters:</p> Name Type Description Default <code>ballots</code> <code>list[Ballot]</code> <p>a list of ballots to deduplicate</p> required <p>Returns:</p> Name Type Description <code>Ballot</code> <code>Ballot</code> <p>a ballot with the same ranking and aggregated weight and voters</p> Source code in <code>src/votekit/cleaning.py</code> <pre><code>def merge_ballots(ballots: list[Ballot]) -&gt; Ballot:\n    \"\"\"\n    Takes a list of ballots with the same ranking and merge them into one ballot.\n\n    Args:\n        ballots (list[Ballot]): a list of ballots to deduplicate\n\n    Returns:\n        Ballot: a ballot with the same ranking and aggregated weight and voters\n    \"\"\"\n    weight = sum(b.weight for b in ballots)\n    ranking = ballots[0].ranking\n    voters_to_merge = [b.voters for b in ballots if b.voters]\n    voters = None\n    if len(voters_to_merge) &gt; 0:\n        voters = reduce(lambda b1, b2: b1.union(b2), voters_to_merge)\n        voters = set(voters)\n    return Ballot(ranking=ranking, voters=voters, weight=Fraction(weight))\n</code></pre>"},{"location":"api/#votekit.cleaning.remove_empty_ballots","title":"<code>remove_empty_ballots(pp, keep_candidates=False)</code>","text":"<p>Removes empty ballots from a preference profile.</p> <p>Parameters:</p> Name Type Description Default <code>pp</code> <code>PreferenceProfile</code> <p>a preference profile to clean</p> required <code>keep_candidates</code> <code>bool</code> <p>if True, keep all of the candidates from the original preference profile in the returned preference profile.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>PreferenceProfile</code> <code>PreferenceProfile</code> <p>a cleaned preference profile</p> Source code in <code>src/votekit/cleaning.py</code> <pre><code>def remove_empty_ballots(\n    pp: PreferenceProfile, keep_candidates: bool = False\n) -&gt; PreferenceProfile:\n    \"\"\"\n    Removes empty ballots from a preference profile.\n\n    Args:\n        pp (PreferenceProfile): a preference profile to clean\n        keep_candidates (bool, optional): if True, keep all of the candidates\n            from the original preference profile in the returned preference profile.\n\n    Returns:\n        PreferenceProfile: a cleaned preference profile\n    \"\"\"\n\n    ballots_nonempty = [\n        deepcopy(ballot) for ballot in pp.get_ballots() if ballot.ranking\n    ]\n    if keep_candidates:\n        old_cands = deepcopy(pp.get_candidates())\n        pp_clean = PreferenceProfile(ballots=ballots_nonempty, candidates=old_cands)\n    else:\n        pp_clean = PreferenceProfile(ballots=ballots_nonempty)\n    return pp_clean\n</code></pre>"},{"location":"api/#votekit.cleaning.remove_noncands","title":"<code>remove_noncands(profile, non_cands)</code>","text":"<p>Removes user-assigned non-candidates from ballots, deletes ballots that are empty as a result of the removal.</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>PreferenceProfile</code> <p>a preference profile to clean</p> required <code>non_cands</code> <code>list[str]</code> <p>a list of non-candidates to be removed</p> required <p>Returns:</p> Name Type Description <code>PreferenceProfile</code> <code>PreferenceProfile</code> <p>a profile with non-candidates removed</p> Source code in <code>src/votekit/cleaning.py</code> <pre><code>def remove_noncands(\n    profile: PreferenceProfile, non_cands: list[str]\n) -&gt; PreferenceProfile:\n    \"\"\"\n    Removes user-assigned non-candidates from ballots, deletes ballots\n    that are empty as a result of the removal.\n\n    Args:\n        profile (PreferenceProfile): a preference profile to clean\n        non_cands (list[str]): a list of non-candidates to be removed\n\n    Returns:\n        PreferenceProfile: a profile with non-candidates removed\n    \"\"\"\n\n    def remove_from_ballots(ballot: Ballot, non_cands: list[str]) -&gt; Ballot:\n        \"\"\"\n        Removes non-candidiates from ballot objects.\n\n        Args:\n            ballot (Ballot): a ballot to be cleaned\n            non_cands (list[str]): a list of candidates to remove\n\n        Returns:\n            Ballot: _description_\n        \"\"\"\n        # TODO: adjust so string and list of strings are acceptable inputes\n\n        to_remove = []\n        for item in non_cands:\n            to_remove.append({item})\n\n        ranking = ballot.ranking\n        clean_ranking = []\n        for cand in ranking:\n            if cand not in to_remove and cand not in clean_ranking:\n                clean_ranking.append(cand)\n\n        clean_ballot = Ballot(\n            id=ballot.id,\n            ranking=clean_ranking,\n            weight=Fraction(ballot.weight),\n            voters=ballot.voters,\n        )\n\n        return clean_ballot\n\n    cleaned = [\n        remove_from_ballots(ballot, non_cands)\n        for ballot in profile.ballots\n        if remove_from_ballots(ballot, non_cands).ranking\n    ]\n    grouped_ballots = [\n        list(result)\n        for key, result in groupby(cleaned, key=lambda ballot: ballot.ranking)\n    ]\n    # merge ballots in the same groups\n    new_ballots = [merge_ballots(b) for b in grouped_ballots]\n    return PreferenceProfile(ballots=new_ballots)\n</code></pre>"},{"location":"api/#metrics","title":"Metrics","text":""},{"location":"api/#votekit.utils.borda_scores","title":"<code>borda_scores(profile, ballot_length=None, score_vector=None)</code>","text":"<p>Calculates Borda scores for a PreferenceProfile</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>PreferenceProfile</code> <p>Inputed profile of ballots</p> required <code>ballot_length</code> <code>Optional[int]</code> <p>Length of a ballot, if None length of longest ballot is used</p> <code>None</code> <code>score_vector</code> <code>Optional[list]</code> <p>Borda weights, if None assigned based length of the longest ballot</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of candidates (keys) and Borda scores (values)</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def borda_scores(\n    profile: PreferenceProfile,\n    ballot_length: Optional[int] = None,\n    score_vector: Optional[list] = None,\n) -&gt; dict:\n    \"\"\"\n    Calculates Borda scores for a PreferenceProfile\n\n    Args:\n        profile: Inputed profile of ballots\n        ballot_length: Length of a ballot, if None length of longest ballot is\n            used\n        score_vector: Borda weights, if None assigned based length of the\n            longest ballot\n\n    Returns:\n        Dictionary of candidates (keys) and Borda scores (values)\n    \"\"\"\n    candidates = profile.get_candidates()\n    if ballot_length is None:\n        ballot_length = max([len(ballot.ranking) for ballot in profile.ballots])\n    if score_vector is None:\n        score_vector = list(range(ballot_length, 0, -1))\n\n    candidate_borda = {c: Fraction(0) for c in candidates}\n    for ballot in profile.ballots:\n        current_ind = 0\n        candidates_covered = []\n        for s in ballot.ranking:\n            position_size = len(s)\n            local_score_vector = score_vector[current_ind : current_ind + position_size]\n            borda_allocation = sum(local_score_vector) / position_size\n            for c in s:\n                candidate_borda[c] += Fraction(borda_allocation) * ballot.weight\n            current_ind += position_size\n            candidates_covered += list(s)\n\n        # If ballot was incomplete, evenly allocation remaining points\n        if current_ind &lt; len(score_vector):\n            remainder_cands = set(candidates).difference(set(candidates_covered))\n            remainder_score_vector = score_vector[current_ind:]\n            remainder_borda_allocation = sum(remainder_score_vector) / len(\n                remainder_cands\n            )\n            for c in remainder_cands:\n                candidate_borda[c] += (\n                    Fraction(remainder_borda_allocation) * ballot.weight\n                )\n\n    return candidate_borda\n</code></pre>"},{"location":"api/#votekit.utils.first_place_votes","title":"<code>first_place_votes(profile)</code>","text":"<p>Calculates first-place votes for a PreferenceProfile</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>PreferenceProfile</code> <p>Inputed profile of ballots</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of candidates (keys) and first place vote totals (values)</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def first_place_votes(profile: PreferenceProfile) -&gt; dict:\n    \"\"\"\n    Calculates first-place votes for a PreferenceProfile\n\n    Args:\n        profile: Inputed profile of ballots\n\n    Returns:\n        Dictionary of candidates (keys) and first place vote totals (values)\n    \"\"\"\n    cands = profile.get_candidates()\n    ballots = profile.get_ballots()\n\n    return {cand: float(votes) for cand, votes in compute_votes(cands, ballots)}\n</code></pre>"},{"location":"api/#votekit.utils.mentions","title":"<code>mentions(profile)</code>","text":"<p>Calculates total mentions for a PreferenceProfile</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>PreferenceProfile</code> <p>Inputed profile of ballots</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of candidates (keys) and mention totals (values)</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def mentions(profile: PreferenceProfile) -&gt; dict:\n    \"\"\"\n    Calculates total mentions for a PreferenceProfile\n\n    Args:\n        profile: Inputed profile of ballots\n\n    Returns:\n        Dictionary of candidates (keys) and mention totals (values)\n    \"\"\"\n    mentions: dict[str, float] = {}\n\n    ballots = profile.get_ballots()\n    for ballot in ballots:\n        for rank in ballot.ranking:\n            for cand in rank:\n                if cand not in mentions:\n                    mentions[cand] = 0\n                if len(rank) &gt; 1:\n                    mentions[cand] += (1 / len(rank)) * int(\n                        ballot.weight\n                    )  # split mentions for candidates that are tied\n                else:\n                    mentions[cand] += float(ballot.weight)\n\n    return mentions\n</code></pre>"},{"location":"api/#votekit.metrics.distances.earth_mover_dist","title":"<code>earth_mover_dist(pp1, pp2)</code>","text":"<p>Computes the earth mover distance between two elections. </p> <p>Assumes both elections share the same candidates</p> <p>Parameters:</p> Name Type Description Default <code>pp1</code> <code>PreferenceProfile</code> <p>Profile for first election</p> required <code>pp2</code> <code>PreferenceProfile</code> <p>Profile for second election</p> required <p>Returns:</p> Type Description <code>int</code> <p>Earth mover distance between inputted elections</p> Source code in <code>src/votekit/metrics/distances.py</code> <pre><code>def earth_mover_dist(pp1: PreferenceProfile, pp2: PreferenceProfile) -&gt; int:\n    \"\"\"\n    Computes the earth mover distance between two elections. \\n\n    Assumes both elections share the same candidates\n\n    Args:\n        pp1: Profile for first election\n        pp2: Profile for second election\n\n    Returns:\n        Earth mover distance between inputted elections\n    \"\"\"\n    # create ballot graph\n    ballot_graph = BallotGraph(source=pp2).graph\n    # ballot_graph = graph.from_profile(profile=pp2, complete=True)\n\n    # Solving Earth Mover Distance\n    electA_distr = np.array(em_array(pp=pp1))\n    electB_distr = np.array(em_array(pp=pp2))\n\n    # Floyd Warshall Shortest Distance alorithm. Returns a dictionary of shortest path for each node\n    fw_dist_dict = nx.floyd_warshall(ballot_graph)\n    keys_list = sorted(fw_dist_dict.keys())\n    cost_matrix = np.zeros((len(keys_list), len(keys_list)))\n    for i in range(len(keys_list)):\n        node_dict = fw_dist_dict[keys_list[i]]\n        cost_col = [value for key, value in sorted(node_dict.items())]\n        cost_matrix[i] = cost_col\n    earth_mover_matrix = ot.emd(electA_distr, electB_distr, cost_matrix)\n\n    # Hadamard Product = Earth mover dist between two matrices\n    earth_mover_dist = np.sum(np.multiply(cost_matrix, earth_mover_matrix))\n    return earth_mover_dist\n</code></pre>"},{"location":"api/#votekit.metrics.distances.lp_dist","title":"<code>lp_dist(pp1, pp2, p_value=1)</code>","text":"<p>Computes the L_p distance between two election distributions. Use 'inf' for infinity norm. </p> <p>Assumes both elections share the same candidates.</p> <p>Parameters:</p> Name Type Description Default <code>pp1</code> <code>PreferenceProfile</code> <p>Profile for first election</p> required <code>pp2</code> <code>PreferenceProfile</code> <p>Profile for second election</p> required <code>p_value</code> <code>Optional[Union[int, str]]</code> <p>Distance parameter, 1 for Manhattan, 2 for Euclidean </p> <p>or 'inf' for Chebyshev distance</p> <code>1</code> <p>Returns:</p> Type Description <code>int</code> <p>Lp distance between two elections</p> Source code in <code>src/votekit/metrics/distances.py</code> <pre><code>def lp_dist(\n    pp1: PreferenceProfile,\n    pp2: PreferenceProfile,\n    p_value: Optional[Union[int, str]] = 1,\n) -&gt; int:\n    \"\"\"\n    Computes the L_p distance between two election distributions.\n    Use 'inf' for infinity norm. \\n\n    Assumes both elections share the same candidates.\n\n    Args:\n        pp1: Profile for first election\n        pp2: Profile for second election\n        p_value: Distance parameter, 1 for Manhattan, 2 for Euclidean \\n\n            or 'inf' for Chebyshev distance\n\n    Returns:\n        Lp distance between two elections\n    \"\"\"\n    pp_list = [pp1, pp2]\n    pp_2arry = profiles_to_ndarrys(pp_list)\n    electA = pp_2arry[:, 0]\n    electB = pp_2arry[:, 1]\n\n    if isinstance(p_value, int):\n        sum = 0\n        for i in range(len(electA)):\n            diff = (abs(electA[i] - electB[i])) ** p_value\n            sum += diff\n        lp_dist = sum ** (1 / p_value)\n        return lp_dist\n\n    elif p_value == \"inf\":\n        diff = [abs(x - y) for x, y in zip(electA, electB)]\n        return max(diff)\n\n    else:\n        raise ValueError(\"Unsupported input type\")\n</code></pre>"},{"location":"api/#votekit.metrics.distances.em_array","title":"<code>em_array(pp)</code>","text":"<p>Converts a PreferenceProfile into a distribution using ballot graphs.</p> <p>Parameters:</p> Name Type Description Default <code>pp</code> <code>PreferenceProfile</code> <p>Profile for a given election</p> required <p>Returns:</p> Type Description <code>list</code> <p>Distribution of ballots for an election</p> Source code in <code>src/votekit/metrics/distances.py</code> <pre><code>def em_array(pp: PreferenceProfile) -&gt; list:\n    \"\"\"\n    Converts a PreferenceProfile into a distribution using ballot graphs.\n\n    Args:\n        pp: Profile for a given election\n\n    Returns:\n        Distribution of ballots for an election\n    \"\"\"\n    ballot_graph = BallotGraph(source=pp)\n    node_cand_map = ballot_graph.label_cands(sorted(pp.get_candidates()))\n    pp_dict = pp.to_dict(True)\n\n    # invert node_cand_map to map to pp_dict\n    inverted = {v: k for k, v in node_cand_map.items()}\n    combined_dict = {k: 0 for k in node_cand_map}\n\n    # map nodes with weight of corresponding rank\n    node_pp_dict = {inverted[key]: pp_dict[key] for key in pp_dict}\n\n    complete_election_dict = combined_dict | node_pp_dict\n    elect_distr = [\n        float(complete_election_dict[key])\n        for key in sorted(complete_election_dict.keys())\n    ]\n\n    return elect_distr\n</code></pre>"},{"location":"api/#votekit.elections.transfers.fractional_transfer","title":"<code>fractional_transfer(winner, ballots, votes, threshold)</code>","text":"<p>Calculates fractional transfer from winner, then removes winner from the list of ballots</p> <p>Parameters:</p> Name Type Description Default <code>winner</code> <code>str</code> <p>Candidate to transfer votes from</p> required <code>ballots</code> <code>list[Ballot]</code> <p>List of Ballot objects</p> required <code>votes</code> <code>dict</code> <p>Contains candidates and their corresponding vote totals</p> required <code>threshold</code> <code>int</code> <p>Value required to be elected, used to calculate transfer value</p> required <p>Returns:</p> Type Description <code>list[Ballot]</code> <p>Modified ballots with transfered weights and the winning canidated removed</p> Source code in <code>src/votekit/elections/transfers.py</code> <pre><code>def fractional_transfer(\n    winner: str, ballots: list[Ballot], votes: dict, threshold: int\n) -&gt; list[Ballot]:\n    \"\"\"\n    Calculates fractional transfer from winner, then removes winner\n    from the list of ballots\n\n    Args:\n        winner: Candidate to transfer votes from\n        ballots: List of Ballot objects\n        votes: Contains candidates and their corresponding vote totals\n        threshold: Value required to be elected, used to calculate transfer value\n\n    Returns:\n        Modified ballots with transfered weights and the winning canidated removed\n    \"\"\"\n    transfer_value = (votes[winner] - threshold) / votes[winner]\n\n    for ballot in ballots:\n        new_ranking = []\n        if ballot.ranking and ballot.ranking[0] == {winner}:\n            ballot.weight = ballot.weight * transfer_value\n            for cand in ballot.ranking:\n                if cand != {winner}:\n                    new_ranking.append(cand)\n\n    return remove_cand(winner, ballots)\n</code></pre>"},{"location":"api/#votekit.elections.transfers.seqRCV_transfer","title":"<code>seqRCV_transfer(winner, ballots, votes, threshold)</code>","text":"<p>Transfer method Sequential RCV elections</p> <p>Parameters:</p> Name Type Description Default <code>winner</code> <code>str</code> <p>Candidate to transfer votes from</p> required <code>ballots</code> <code>list[Ballot]</code> <p>List of Ballot objects</p> required <code>votes</code> <code>dict</code> <p>Contains candidates and their corresponding vote totals</p> required <code>threshold</code> <code>int</code> <p>Value required to be elected, used to calculate transfer value</p> required <p>Returns:</p> Type Description <code>list[Ballot]</code> <p>Original list of ballots as Sequential RCV does not transfer votes</p> Source code in <code>src/votekit/elections/transfers.py</code> <pre><code>def seqRCV_transfer(\n    winner: str, ballots: list[Ballot], votes: dict, threshold: int\n) -&gt; list[Ballot]:\n    \"\"\"\n    Transfer method Sequential RCV elections\n\n    Args:\n        winner: Candidate to transfer votes from\n        ballots: List of Ballot objects\n        votes: Contains candidates and their corresponding vote totals\n        threshold: Value required to be elected, used to calculate transfer value\n\n    Returns:\n        Original list of ballots as Sequential RCV does not transfer votes\n    \"\"\"\n    return ballots\n</code></pre>"},{"location":"api/#votekit.elections.transfers.random_transfer","title":"<code>random_transfer(winner, ballots, votes, threshold)</code>","text":"<p>Cambridge-style transfer where transfer ballots are selected randomly</p> <p>Parameters:</p> Name Type Description Default <code>winner</code> <code>str</code> <p>Candidate to transfer votes from</p> required <code>ballots</code> <code>list[Ballot]</code> <p>List of Ballot objects</p> required <code>votes</code> <code>dict</code> <p>Contains candidates and their corresponding vote totals</p> required <code>threshold</code> <code>int</code> <p>Value required to be elected, used to calculate transfer value</p> required <p>Returns:</p> Type Description <code>list[Ballot]</code> <p>Modified ballots with transfered weights and the winning canidated removed</p> Source code in <code>src/votekit/elections/transfers.py</code> <pre><code>def random_transfer(\n    winner: str, ballots: list[Ballot], votes: dict, threshold: int\n) -&gt; list[Ballot]:\n    \"\"\"\n    Cambridge-style transfer where transfer ballots are selected randomly\n\n    Args:\n        winner: Candidate to transfer votes from\n        ballots: List of Ballot objects\n        votes: Contains candidates and their corresponding vote totals\n        threshold: Value required to be elected, used to calculate transfer value\n\n    Returns:\n        Modified ballots with transfered weights and the winning canidated removed\n    \"\"\"\n\n    # turn all of winner's ballots into (multiple) ballots of weight 1\n    weight_1_ballots = []\n    for ballot in ballots:\n        if ballot.ranking and ballot.ranking[0] == {winner}:\n            # note: under random transfer, weights should always be integers\n            for _ in range(int(ballot.weight)):\n                weight_1_ballots.append(\n                    Ballot(\n                        id=ballot.id,\n                        ranking=ballot.ranking,\n                        weight=Fraction(1),\n                        voters=ballot.voters,\n                    )\n                )\n\n    # remove winner's ballots\n    ballots = [\n        ballot\n        for ballot in ballots\n        if not (ballot.ranking and ballot.ranking[0] == {winner})\n    ]\n\n    surplus_ballots = random.sample(weight_1_ballots, int(votes[winner]) - threshold)\n    ballots += surplus_ballots\n\n    transfered = remove_cand(winner, ballots)\n\n    return transfered\n</code></pre>"},{"location":"api/#plotting","title":"Plotting","text":""},{"location":"api/#votekit.plots.mds.distance_matrix","title":"<code>distance_matrix(pp_arr, distance, *args, **kwargs)</code>","text":"<p>Creates pairwise distance matrix between preference profiles. The i-th and j-th entry are pairwise distance between i-th col preference profile and the j-th row preference profile.</p> <p>Parameters:</p> Name Type Description Default <code>pp_arr</code> <code>list[PreferenceProfile]</code> <p>List of preference profiles</p> required <code>distance</code> <code>Callable[..., int]</code> <p>Callable distance function type. See distance.py</p> required <p>Returns:</p> Type Description <p>Distance matrix for an election</p> Source code in <code>src/votekit/plots/mds.py</code> <pre><code>def distance_matrix(\n    pp_arr: list[PreferenceProfile], distance: Callable[..., int], *args, **kwargs\n):\n    \"\"\"\n    Creates pairwise distance matrix between preference profiles. The i-th and\n    j-th entry are pairwise distance between i-th col preference profile and\n    the j-th row preference profile.\n\n    Args:\n        pp_arr: List of preference profiles\n        distance: Callable distance function type. See distance.py\n\n    Returns:\n        Distance matrix for an election\n    \"\"\"\n    rows = len(pp_arr)\n    dist_matrix = np.zeros((rows, rows))\n\n    for i in range(rows):\n        for j in range(i + 1, rows):\n            dist_matrix[i][j] = distance(pp_arr[i], pp_arr[j], *args, **kwargs)\n            dist_matrix[j][i] = dist_matrix[i][j]\n    return dist_matrix\n</code></pre>"},{"location":"api/#votekit.plots.mds.plot_MDS","title":"<code>plot_MDS(data, distance, marker_size=5, *args, **kwargs)</code>","text":"<p>Creates a multidimensional scaling plot.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, list[PreferenceProfile]]</code> <p>Dictionary with key being a 'color' and value being list of </p> required <code>PreferenceProfiles.</code> <code>ex</code> <p>{'color': list[PreferenceProfile]}</p> required <code>distance</code> <code>Callable[..., int]</code> <p>Distance function</p> required <code>marker_size</code> <code>Optional[int]</code> <p>Size of plotted points</p> <code>5</code> <p>Returns:</p> Type Description <p>An MDS plot</p> Source code in <code>src/votekit/plots/mds.py</code> <pre><code>def plot_MDS(\n    data: Dict[str, list[PreferenceProfile]],\n    distance: Callable[..., int],\n    marker_size: Optional[int] = 5,\n    *args,\n    **kwargs\n):\n    \"\"\"\n    Creates a multidimensional scaling plot.\n\n    Args:\n        data: Dictionary with key being a 'color' and value being list of \\n\n        PreferenceProfiles. ex: {'color': list[PreferenceProfile]}\n        distance: Distance function\n        marker_size: Size of plotted points\n\n    Returns:\n        An MDS plot\n    \"\"\"\n    # combine all lists to create distance matrix\n    combined_pp = []\n    for pp_list in data.values():\n        combined_pp.extend(pp_list)\n\n    # compute distance matrix\n    dist_matrix = distance_matrix(combined_pp, distance, *args, **kwargs)\n\n    mds = manifold.MDS(\n        n_components=2,\n        max_iter=3000,\n        eps=1e-9,\n        dissimilarity=\"precomputed\",\n        n_jobs=1,\n        normalized_stress=\"auto\",\n    )\n    pos = mds.fit(np.array(dist_matrix)).embedding_\n\n    # Plot and color data\n    start_pos = 0\n    for key, value_list in data.items():\n        end_pos = start_pos + len(value_list)\n        plt.scatter(\n            pos[start_pos:end_pos, 0],\n            pos[start_pos:end_pos, 1],\n            color=key,\n            lw=0,\n            s=marker_size,\n        )\n        start_pos += len(value_list)\n    plt.title(\"MDS Plot for Pair Wise Election Distances\")\n    plt.show()\n    return plt\n</code></pre>"},{"location":"api/#votekit.plots.profile_plots.plot_summary_stats","title":"<code>plot_summary_stats(profile, stat, multi_color=True, title='')</code>","text":"<p>Plots histogram of election summary statistics</p> <p>Parameters:</p> Name Type Description Default <code>profile</code> <code>PreferenceProfile</code> <p>a preference profile to visualize</p> required <code>stat</code> <code>str</code> <p>'first place votes', 'mentions', or 'borda'</p> required <code>multi_color</code> <code>bool</code> <p>if the bars should be multicolored. Defaults to True.</p> <code>True</code> <code>title</code> <code>str</code> <p>title for the figure. Defaults to None.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>Figure</code> <code>Figure</code> <p>a figure with the visualization</p> Source code in <code>src/votekit/plots/profile_plots.py</code> <pre><code>def plot_summary_stats(\n    profile: PreferenceProfile, stat: str, multi_color: bool = True, title: str = \"\"\n) -&gt; Figure:\n    \"\"\"\n    Plots histogram of election summary statistics\n\n    Args:\n        profile (PreferenceProfile): a preference profile to visualize\n        stat (str): 'first place votes', 'mentions', or 'borda'\n        multi_color (bool, optional): if the bars should be multicolored. Defaults to True.\n        title (str, optional): title for the figure. Defaults to None.\n\n    Returns:\n        Figure: a figure with the visualization\n    \"\"\"\n    stats = {\n        \"first place votes\": first_place_votes,\n        \"mentions\": mentions,\n        \"borda\": borda_scores,\n    }\n\n    stat_func = stats[stat]\n    data: dict = stat_func(profile)  # type: ignore\n\n    if stat == \"first place votes\":\n        ylabel = \"First Place Votes\"\n    elif stat == \"mentions\":\n        ylabel = \"Total Mentions\"\n    else:\n        ylabel = \"Borda Scores\"\n\n    if multi_color:\n        colors = COLOR_LIST[: len(list(data.keys()))]\n    else:\n        colors = [COLOR_LIST[-1]]\n\n    fig, ax = plt.subplots()\n\n    candidates = profile.get_candidates()\n    y_data = [data[c] for c in candidates]\n\n    ax.bar(candidates, y_data, color=colors, width=0.35)\n    ax.set_xlabel(\"Candidates\")\n    ax.set_ylabel(ylabel)\n\n    if title:\n        ax.set_title(title)\n\n    return fig\n</code></pre>"},{"location":"api/#utils","title":"Utils","text":""},{"location":"api/#votekit.utils.compute_votes","title":"<code>compute_votes(candidates, ballots)</code>","text":"<p>Computes first place votes for all candidates in a preference profile</p> <p>Parameters:</p> Name Type Description Default <code>candidates</code> <code>list</code> <p>List of all candidates in a PreferenceProfile</p> required <code>ballots</code> <code>list[Ballot]</code> <p>List of Ballot objects</p> required <p>Returns:</p> Type Description <code>list[CandidateVotes]</code> <p>List of tuples (candidate, number of votes) ordered by first place votes</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def compute_votes(candidates: list, ballots: list[Ballot]) -&gt; list[CandidateVotes]:\n    \"\"\"\n    Computes first place votes for all candidates in a preference profile\n\n    Args:\n        candidates: List of all candidates in a PreferenceProfile\n        ballots: List of Ballot objects\n\n    Returns:\n        List of tuples (candidate, number of votes) ordered by first place votes\n    \"\"\"\n    votes = {cand: Fraction(0) for cand in candidates}\n\n    for ballot in ballots:\n        if not ballot.ranking:\n            continue\n        first_place_cand = unset(ballot.ranking[0])\n        if isinstance(first_place_cand, list):\n            for cand in first_place_cand:\n                votes[cand] += ballot.weight / len(first_place_cand)\n        else:\n            votes[first_place_cand] += ballot.weight\n\n    ordered = [\n        CandidateVotes(cand=key, votes=value)\n        for key, value in sorted(votes.items(), key=lambda x: x[1], reverse=True)\n    ]\n\n    return ordered\n</code></pre>"},{"location":"api/#votekit.utils.remove_cand","title":"<code>remove_cand(removed, ballots)</code>","text":"<p>Removes specified candidate(s) from ballots</p> <p>Parameters:</p> Name Type Description Default <code>removed</code> <code>Union[str, Iterable]</code> <p>Candidate or set of candidates to be removed</p> required <code>ballots</code> <code>list[Ballot]</code> <p>List of Ballots to remove canidate(s) from</p> required <p>Returns:</p> Type Description <code>list[Ballot]</code> <p>Updated list of ballots with candidate(s) removed</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def remove_cand(removed: Union[str, Iterable], ballots: list[Ballot]) -&gt; list[Ballot]:\n    \"\"\"\n    Removes specified candidate(s) from ballots\n\n    Args:\n        removed: Candidate or set of candidates to be removed\n        ballots: List of Ballots to remove canidate(s) from\n\n    Returns:\n        Updated list of ballots with candidate(s) removed\n    \"\"\"\n\n    if isinstance(removed, str):\n        remove_set = {removed}\n    elif isinstance(removed, Iterable):\n        remove_set = set(removed)\n\n    update = []\n    for ballot in ballots:\n        new_ranking = []\n        if len(remove_set) == 1 and remove_set in ballot.ranking:\n            for s in ballot.ranking:\n                new_s = s.difference(remove_set)\n                if new_s:\n                    new_ranking.append(new_s)\n            update.append(\n                Ballot(\n                    id=ballot.id,\n                    ranking=new_ranking,\n                    weight=ballot.weight,\n                    voters=ballot.voters,\n                )\n            )\n        elif len(remove_set) &gt; 1:\n            for s in ballot.ranking:\n                new_s = s.difference(remove_set)\n                if new_s:\n                    new_ranking.append(new_s)\n            update.append(\n                Ballot(\n                    id=ballot.id,\n                    ranking=new_ranking,\n                    weight=ballot.weight,\n                    voters=ballot.voters,\n                )\n            )\n        else:\n            update.append(ballot)\n\n    return update\n</code></pre>"},{"location":"api/#votekit.utils.unset","title":"<code>unset(input_set)</code>","text":"<p>Removes object from set</p> <p>Parameters:</p> Name Type Description Default <code>input_set</code> <code>set</code> <p>Input set</p> required <p>Returns:</p> Type Description <code>Any</code> <p>If set has length one returns the object, else returns a list</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def unset(input_set: set) -&gt; Any:\n    \"\"\"\n    Removes object from set\n\n    Args:\n        input_set: Input set\n\n    Returns:\n        If set has length one returns the object, else returns a list\n    \"\"\"\n    rv = list(input_set)\n\n    if len(rv) == 1:\n        return rv[0]\n\n    return rv\n</code></pre>"},{"location":"api/#votekit.utils.recursively_fix_ties","title":"<code>recursively_fix_ties(ballot_lst, num_ties)</code>","text":"<p>Recursively fixes ties in a ballot in the case there is more then one tie</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def recursively_fix_ties(ballot_lst: list[Ballot], num_ties: int) -&gt; list[Ballot]:\n    \"\"\"\n    Recursively fixes ties in a ballot in the case there is more then one tie\n    \"\"\"\n    # base case, if only one tie to resolved return the list of already\n    # resolved ballots\n    if num_ties == 1:\n        return ballot_lst\n\n    # in the event multiple positions have ties\n    else:\n        update = set()\n        for ballot in ballot_lst:\n            update.update(set(fix_ties(ballot)))\n\n        return recursively_fix_ties(list(update), num_ties - 1)\n</code></pre>"},{"location":"api/#votekit.utils.fix_ties","title":"<code>fix_ties(ballot)</code>","text":"<p>Helper function for recursively_fix_ties. Resolves the first appearing tied rank in the input ballot by return list of permuted ballots</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def fix_ties(ballot: Ballot) -&gt; list[Ballot]:\n    \"\"\"\n    Helper function for recursively_fix_ties. Resolves the first appearing\n    tied rank in the input ballot by return list of permuted ballots\n    \"\"\"\n\n    ballots = []\n    for idx, rank in enumerate(ballot.ranking):\n        if len(rank) &gt; 1:\n            for order in permutations(rank):\n                resolved = []\n                for cand in order:\n                    resolved.append(set(cand))\n                ballots.append(\n                    Ballot(\n                        id=ballot.id,\n                        ranking=ballot.ranking[:idx]\n                        + resolved\n                        + ballot.ranking[idx + 1 :],\n                        weight=ballot.weight / math.factorial(len(rank)),\n                        voters=ballot.voters,\n                    )\n                )\n\n    return ballots\n</code></pre>"},{"location":"api/#votekit.utils.elect_cands_from_set_ranking","title":"<code>elect_cands_from_set_ranking(ranking, seats)</code>","text":"<p>Splits a ranking into elected and eliminated based on seats, and if a tie set overlaps the desired number of seats raises a ValueError</p> <p>Parameters:</p> Name Type Description Default <code>ranking</code> <code>list[set[str]]</code> <p>A list-of-set ranking of candidates</p> required <code>seats</code> <code>int</code> <p>Number of seats to fill</p> required <p>Returns:</p> Type Description <code>tuple[list[set[str]], list[set[str]]]</code> <p>A list-of-sets of elected candidates, a list-of-sets of eliminated candidates</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def elect_cands_from_set_ranking(\n    ranking: list[set[str]], seats: int\n) -&gt; tuple[list[set[str]], list[set[str]]]:\n    \"\"\"\n    Splits a ranking into elected and eliminated based on seats,\n    and if a tie set overlaps the desired number of seats raises a ValueError\n\n    Args:\n        ranking: A list-of-set ranking of candidates\n        seats: Number of seats to fill\n\n    Returns:\n        A list-of-sets of elected candidates, a list-of-sets of eliminated candidates\n    \"\"\"\n    cands_elected = 0\n    elected = []\n    eliminated = []\n\n    for i, s in enumerate(ranking):\n        if cands_elected + len(s) &lt;= seats:\n            cands_elected += len(s)\n            elected.append(s)\n        else:\n            eliminated = ranking[i:]\n            break\n\n    if cands_elected != seats:\n        raise ValueError(\n            \"Cannot elect correct number of candidates without breaking ties.\"\n        )\n\n    return elected, eliminated\n</code></pre>"},{"location":"api/#votekit.utils.scores_into_set_list","title":"<code>scores_into_set_list(score_dict, candidate_subset=None)</code>","text":"<p>Sorts candidates based on a scoring dictionary (i.e Borda, First-Place)</p> <p>Parameters:</p> Name Type Description Default <code>score_dict</code> <code>dict</code> <p>Dictionary between candidates (key) and their score (value)</p> required <code>candidate_subset</code> <code>Union[list[str], set[str], None]</code> <p>Relevant candidates to sort</p> <code>None</code> <p>Returns:</p> Type Description <code>list[set[str]]</code> <p>Candidate rankings in a list-of-sets form</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def scores_into_set_list(\n    score_dict: dict, candidate_subset: Union[list[str], set[str], None] = None\n) -&gt; list[set[str]]:\n    \"\"\"\n    Sorts candidates based on a scoring dictionary (i.e Borda, First-Place)\n\n    Args:\n        score_dict: Dictionary between candidates (key) and their score (value)\n        candidate_subset: Relevant candidates to sort\n\n    Returns:\n        Candidate rankings in a list-of-sets form\n    \"\"\"\n    if isinstance(candidate_subset, list):\n        candidate_subset = set(candidate_subset)\n\n    tier_dict: dict = {}\n    for k, v in score_dict.items():\n        if v in tier_dict.keys():\n            tier_dict[v].add(k)\n        else:\n            tier_dict[v] = {k}\n    tier_list = [tier_dict[k] for k in sorted(tier_dict.keys(), reverse=True)]\n    if candidate_subset is not None:\n        tier_list = [\n            t &amp; candidate_subset for t in tier_list if len(t &amp; candidate_subset) &gt; 0\n        ]\n    return tier_list\n</code></pre>"},{"location":"api/#votekit.utils.tie_broken_ranking","title":"<code>tie_broken_ranking(ranking, profile, tiebreak='none')</code>","text":"<p>Breaks ties in a list-of-sets ranking according to a given scheme</p> <p>Parameters:</p> Name Type Description Default <code>ranking</code> <code>list[set[str]]</code> <p>A list-of-set ranking of candidates</p> required <code>profile</code> <code>PreferenceProfile</code> <p>The election ballot profile</p> required <code>tiebreak</code> <code>str</code> <p>Method of tiebreak, currently supports 'none', 'random', 'borda', 'firstplace'</p> <code>'none'</code> <p>Returns:</p> Type Description <code>list[set[str]]</code> <p>A list-of-set ranking of candidates (tie broken down to one candidate sets unless tiebreak = 'none')</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def tie_broken_ranking(\n    ranking: list[set[str]], profile: PreferenceProfile, tiebreak: str = \"none\"\n) -&gt; list[set[str]]:\n    \"\"\"\n    Breaks ties in a list-of-sets ranking according to a given scheme\n\n    Args:\n        ranking: A list-of-set ranking of candidates\n        profile: The election ballot profile\n        tiebreak: Method of tiebreak, currently supports 'none', 'random', 'borda', 'firstplace'\n\n    Returns:\n        A list-of-set ranking of candidates (tie broken down to one candidate sets unless\n            tiebreak = 'none')\n    \"\"\"\n\n    new_ranking = []\n    if tiebreak == \"none\":\n        new_ranking = ranking\n    elif tiebreak == \"random\":\n        for s in ranking:\n            shuffled_s = list(np.random.permutation(list(s)))\n            new_ranking += [{c} for c in shuffled_s]\n    elif tiebreak == \"firstplace\":\n        tiebreak_scores = first_place_votes(profile)\n        for s in ranking:\n            ordered_set = scores_into_set_list(tiebreak_scores, s)\n            new_ranking += ordered_set\n    elif tiebreak == \"borda\":\n        tiebreak_scores = borda_scores(profile)\n        for s in ranking:\n            ordered_set = scores_into_set_list(tiebreak_scores, s)\n            new_ranking += ordered_set\n    else:\n        raise ValueError(\"Invalid tiebreak code was provided\")\n\n    if tiebreak != \"none\" and any(len(s) &gt; 1 for s in new_ranking):\n        print(\"Initial tiebreak was unsuccessful, performing random tiebreak\")\n        new_ranking = tie_broken_ranking(\n            ranking=new_ranking, profile=profile, tiebreak=\"random\"\n        )\n\n    return new_ranking\n</code></pre>"},{"location":"api/#votekit.utils.candidate_position_dict","title":"<code>candidate_position_dict(ranking)</code>","text":"<p>Creates a dictionary with the integer ranking of candidates given a set ranking i.e. A &gt; B, C &gt; D returns {A: 1, B: 2, C: 2, D: 4}</p> <p>Parameters:</p> Name Type Description Default <code>ranking</code> <code>list[set[str]]</code> <p>A list-of-set ranking of candidates</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary of candidates (keys) and integer rankings (values)</p> Source code in <code>src/votekit/utils.py</code> <pre><code>def candidate_position_dict(ranking: list[set[str]]) -&gt; dict:\n    \"\"\"\n    Creates a dictionary with the integer ranking of candidates given a set ranking\n    i.e. A &gt; B, C &gt; D returns {A: 1, B: 2, C: 2, D: 4}\n\n    Args:\n        ranking: A list-of-set ranking of candidates\n\n    Returns:\n        Dictionary of candidates (keys) and integer rankings (values)\n    \"\"\"\n    candidate_positions = {}\n    position = 0\n\n    for tie_set in ranking:\n        for candidate in tie_set:\n            candidate_positions[candidate] = position\n        position += len(tie_set)\n\n    return candidate_positions\n</code></pre>"},{"location":"ballot_graph_tutorial/","title":"Ballot Graphs","text":"<p>The ballot graph has vertices=ballots, and edges connecting ballots if they are equivalent by a swap of two adjacently ranked candidates, or by the truncation or addition of a candidate in last place.</p> <p>The <code>BallotGraph</code> object can be created from a <code>PreferenceProfile</code> object, a number of candidates, or a list of candidates. It has an <code>allow_partial</code> parameter that says whether or not the graph will be constructed using partial ballots, or only full linear orderings. If being created from a <code>PreferenceProfile</code>, this parameter defaults to <code>True</code> to allow for any kind of ballot from a voter.</p> <pre><code>import votekit.ballot_generator as bg\nfrom votekit.graphs import BallotGraph\n</code></pre> <pre><code>candidates = [\"A\", \"B\", \"C\"]\n\nballot_graph = BallotGraph(candidates, allow_partial=True)\nballot_graph.draw(labels= False)\n</code></pre> <p></p> <p>Why are there no ballots of length 2? Since the number of candidates was 3, any ballot of length 2 is equivalent to a ballot of length 3.</p> <p>We can change the <code>allow_partial</code> parameter to <code>False</code> to only see full linear rankings, and we can also ask the <code>draw</code> method to display the labels of the candidates and how many votes a particular ballot received.</p> <pre><code>ballot_graph = BallotGraph(candidates, allow_partial = False)\nballot_graph.draw(labels = True)\n</code></pre> <p></p> <p>Check for understanding: why are all of the votes 0?</p> <p>The BallotGraph has an underlying <code>graph</code> attribute which stores a NetworkX graph.</p> <pre><code>for node, data in ballot_graph.graph.nodes(data = True):\n    print(node,data)\n</code></pre> <pre><code>(1, 2, 3) {'weight': 0, 'cast': False}\n(1, 3, 2) {'weight': 0, 'cast': False}\n(2, 3, 1) {'weight': 0, 'cast': False}\n(2, 1, 3) {'weight': 0, 'cast': False}\n(3, 1, 2) {'weight': 0, 'cast': False}\n(3, 2, 1) {'weight': 0, 'cast': False}\n</code></pre> <p>This is a bit of a boring example; since the <code>BallotGraph</code> was generated from a list of candidates, none of the ballots have any weight and none of the ballots were \"cast,\" (i.e., 0 people voted with that ballot).</p> <p>If we generate the <code>BallotGraph</code> from a <code>PreferenceProfile</code>, we should get more interesting results here.</p> <pre><code>ic = bg.ImpartialCulture(candidates=candidates)\nnum_ballots = 60\nprofile = ic.generate_profile(number_of_ballots = num_ballots)\nprint(profile)\n\nballot_graph = BallotGraph(profile)\nballot_graph.draw(labels = True)\n</code></pre> <pre><code>  Ballots  Weight\n(B, C, A)      13\n(C, A, B)      13\n(B, A, C)      11\n(A, C, B)      10\n(C, B, A)       7\n(A, B, C)       6\n</code></pre> <p></p> <p>Let's dig into the node atttributes of the graph to see how the voting information was captured.</p> <pre><code>for node, data in ballot_graph.graph.nodes(data = True):\n    print(node,data)\n</code></pre> <pre><code>(1,) {'weight': 0, 'cast': False}\n(1, 2, 3) {'weight': Fraction(13, 1), 'cast': True}\n(1, 3, 2) {'weight': Fraction(7, 1), 'cast': True}\n(2,) {'weight': 0, 'cast': False}\n(2, 3, 1) {'weight': Fraction(6, 1), 'cast': True}\n(2, 1, 3) {'weight': Fraction(10, 1), 'cast': True}\n(3,) {'weight': 0, 'cast': False}\n(3, 1, 2) {'weight': Fraction(13, 1), 'cast': True}\n(3, 2, 1) {'weight': Fraction(11, 1), 'cast': True}\n</code></pre> <p>Check for understanding: only ballots that were in the <code>PreferenceProfile</code> should have 'cast'= True, and their 'weight' attribute should correspond to the number of ballots cast.</p> <p>If we wanted to visualize only the nodes corresponding to cast ballots, we use the <code>show_cast</code> parameter in the <code>draw</code> method.</p> <pre><code>ballot_graph.draw(labels = True, show_cast=True)\n</code></pre> <p></p> <p>We can also write custom functions for displaying nodes. We require these functions to take as input the underlying graph and a node, and return <code>True</code> if the node is to be displayed. Suppose we only wanted to see </p> <pre><code>def show_big_weight(graph, node):\n    # display nodes with more than 10 votes\n    if graph.nodes[node][\"weight\"] &gt;= 10:\n        return True\n\n    return False\n</code></pre> <pre><code>ballot_graph.draw(labels=True, to_display=show_big_weight)\n</code></pre> <p></p> <p>What if we wanted to explore a particular neighborhood of a ballot? Let's look at the radius 1 neighborhood around the ballot (3,2,1).</p> <pre><code># first draw the entire graph so we know what to look for\nballot_graph = BallotGraph(3)\nballot_graph.draw()\n</code></pre> <p></p> <pre><code># the neighborhoods parameter takes a list of tuples (node, radius)\n# and displays the corresponding neighborhoods\nballot_graph.draw(neighborhoods=[((3,2,1), 1)])\n</code></pre> <p></p> <p>Check for understanding: is this picture what you expected?</p> <p>We can also draw multiple neighborhoods.</p> <pre><code>ballot_graph.draw(neighborhoods=[((3,2,1), 1),\n                                 ((2,), 1)])\n</code></pre> <p></p>"},{"location":"getting_started/","title":"Getting started with VoteKit","text":"<p>This guide will help you get started using <code>votekit</code>, by using real election data from the 2013 Minneapolis mayoral election. This election had 35 candidates running for one seat, and used a single-winner IRV method to elect the winner. Voters were allowed to rank their top three candidates. </p> <pre><code># these are the votekit functions we'll need access to\nfrom votekit load_csv, remove_noncands\nfrom votekit.elections import STV, fractional_transfer\n</code></pre> <p>You can find the necessary csv file <code>mn_2013_cast_vote_record.csv</code> in the <code>votekit/data</code> folder of the GitHub repo. Alternatively, you can download the offical cast vote record (CVR) here. Download a verison of the file, and then edit the path below to where you placed it. The csv file has 3 columns we care about. The first, entitled '1ST CHOICE MAYOR MINNEAPOLIS' in the official CVR, tells us a voters top choice, then the second tells us their second choice, and the third their third choice.</p> <p>The first thing we will do is create a <code>PreferenceProfile</code> object from our csv. A preference profile is a term from the social choice literature that represents the rankings of some set of candidates from some voters. Put another way, a preference profile stores the votes from an election, and is a collection of <code>Ballot</code> objects and candidates. </p> <p>We give the <code>load_csv</code> function the path to the csv file. By default, each column of the csv should correspond to a ranking of a candidate, given in decreasing order (the first column is the voters top choice, the last column their bottom choice.) There are some other optional parameters which you can read about in the documentation.</p> <pre><code># you'll need to edit this path!\nminneapolis_profile = load_csv(\"../src/votekit/data/mn_2013_cast_vote_record.csv\")\n</code></pre> <p>The <code>PreferenceProfile</code> object has lots of helpful methods that allow us to study our votes. Let's use some of them to explore the ballots that were submitted. This is crucial since our data was not preprocessed. There could be undervotes, overvotes, defective, or spoiled ballots.</p> <p>The <code>get_candidates</code> method returns a unique list of candidates.</p> <p><pre><code># returns a list of unique candidates\nprint(minneapolis_profile.get_candidates())\n</code></pre> <pre><code>    ['JAMES \"JIMMY\" L. STROUD, JR.', 'BETSY HODGES', 'EDMUND BERNARD BRUYERE', 'MERRILL ANDERSON', 'CAM WINTON', 'MARK V ANDERSON', 'BOB \"AGAIN\" CARNEY JR', 'CHRISTOPHER CLARK', 'JOHN CHARLES WILSON', 'CAPTAIN JACK SPARROW', 'OLE SAVIOR', 'BOB FINE', 'TROY BENJEGERDES', 'JEFFREY ALAN WAGNER', 'MARK ANDREW', 'CYD GORMAN', 'CHRISTOPHER ROBIN ZIMMERMAN', 'DOUG MANN', 'ABDUL M RAHAMAN \"THE ROCK\"', 'DON SAMUELS', 'undervote', 'ALICIA K. BENNETT', 'JACKIE CHERRYHOMES', 'RAHN V. WORKCUFF', 'MIKE GOULD', 'TONY LANE', 'overvote', 'GREGG A. IVERSON', 'JOHN LESLIE HARTWIG', 'NEAL BAXTER', 'DAN COHEN', 'JAMES EVERETT', 'JOSHUA REA', 'BILL KAHN', 'JAYMIE KELLY', 'STEPHANIE WOODRUFF', 'UWI', 'KURTIS W. HANNA']\n</code></pre> The <code>head</code> method shows the top n ballots. In the first column, we see the ballot that was cast. In the second column, we see how many of that type of ballot were cast.  <pre><code># returns the top n ballots\nminneapolis_profile.head(n=5)\n</code></pre> <pre><code>      Ballots                                   Weight\n           (MARK ANDREW, undervote, undervote)  3864  \n      (BETSY HODGES, MARK ANDREW, DON SAMUELS)  3309  \n      (BETSY HODGES, DON SAMUELS, MARK ANDREW)  3031  \n      (MARK ANDREW, BETSY HODGES, DON SAMUELS)  2502  \n          (BETSY HODGES, undervote, undervote)  2212\n</code></pre></p> <p>Woah, that's a little funky! There's a candidate called 'undervote','overvote', and 'UWI'. In this dataset, 'undervote' says that someone left a ranking blank. The 'overvote' candidate arises when someone lists two candidates in one ranking, and in our data set, we lose any knowledge of their actual preference. 'UWI' stands for unregistered write-in.</p> <p>It's really important to think carefully about how you want to handle cleaning up the ballots, as this depends entirely on the context of a given election. For now, let's assume that we want to get rid of the 'undervote', 'overvote', and 'UWI' candidates. The function <code>remove_noncands</code> will do this for us. If a ballot was \"A B undervote\", it would now be \"A B\". If a ballot was \"A UWI B\" it would now be \"A B\" as well. This might not be how you want to handle such things, but for now let's go with it. </p> <pre><code>minneapolis_profile = remove_noncands(minneapolis_profile, [\"undervote\", \"overvote\", \"UWI\"])\nprint(minneapolis_profile.get_candidates())\n</code></pre> <pre><code>['JAMES \"JIMMY\" L. STROUD, JR.', 'BETSY HODGES', 'EDMUND BERNARD BRUYERE', 'MERRILL ANDERSON', 'CAM WINTON', 'ALICIA K. BENNETT', 'MARK V ANDERSON', 'JACKIE CHERRYHOMES', 'BOB \"AGAIN\" CARNEY JR', 'MIKE GOULD', 'RAHN V. WORKCUFF', 'JOHN CHARLES WILSON', 'CHRISTOPHER CLARK', 'TONY LANE', 'CAPTAIN JACK SPARROW', 'OLE SAVIOR', 'BOB FINE', 'TROY BENJEGERDES', 'JOHN LESLIE HARTWIG', 'JEFFREY ALAN WAGNER', 'NEAL BAXTER', 'GREGG A. IVERSON', 'DAN COHEN', 'MARK ANDREW', 'JAMES EVERETT', 'JOSHUA REA', 'CYD GORMAN', 'CHRISTOPHER ROBIN ZIMMERMAN', 'BILL KAHN', 'DOUG MANN', 'JAYMIE KELLY', 'ABDUL M RAHAMAN \"THE ROCK\"', 'DON SAMUELS', 'STEPHANIE WOODRUFF', 'KURTIS W. HANNA']\n</code></pre> <p>Alright, things are looking a bit cleaner. Let's examine some of the ballots.</p> <pre><code># returns the top n ballots\nminneapolis_profile.head(n=5, percents = True)\n</code></pre> <pre><code>  Ballots                                   Weight  Voter Share\n                            (MARK ANDREW,)  3864    0.048678   \n  (BETSY HODGES, MARK ANDREW, DON SAMUELS)  3309    0.041687   \n  (BETSY HODGES, DON SAMUELS, MARK ANDREW)  3031    0.038184   \n  (MARK ANDREW, BETSY HODGES, DON SAMUELS)  2502    0.031520   \n                           (BETSY HODGES,)  2212    0.027867\n</code></pre> <p>We can similarly print the bottom n ballots. Here we toggle the optional <code>percents</code> and <code>totals</code> arguments, which will show us the fraction of the total vote, as well as sum up the weights.</p> <pre><code># returns the bottom n ballots\nminneapolis_profile.tail(n=5, percents = False, totals = True)\n</code></pre> <pre><code>       Ballots                                    Weight\n                                 (MARK ANDREW,)   3864 \n       (BETSY HODGES, MARK ANDREW, DON SAMUELS)   3309 \n       (BETSY HODGES, DON SAMUELS, MARK ANDREW)   3031 \n       (MARK ANDREW, BETSY HODGES, DON SAMUELS)   2502 \n                                (BETSY HODGES,)   2212 \nTotals                                            14918\n</code></pre> <p>There are a few other methods you can read about in the documentation, but now let's run an election!</p> <p>Just because we have a collection of ballots does not mean we have a winner. To convert a PreferenceProfile into a winner (or winners), we need to choose a method of election. The mayoral race was conducted as a single winner IRV election, which in <code>votekit</code> is equivalent to a STV election with one seat. The transfer method tells us what to do if someone has a surplus of votes over the winning quota (which by default is the Droop quota). </p> <pre><code>minn_election = STV(profile = minneapolis_profile, transfer = fractional_transfer, seats = 1)\n</code></pre> <pre><code># the run_election method prints a dataframe showing the order in which candidates are eliminated under STV\nminn_election.run_election()\n</code></pre> <pre><code>                   Candidate     Status  Round\n                BETSY HODGES    Elected     35\n                 MARK ANDREW Eliminated     34\n                 DON SAMUELS Eliminated     33\n                  CAM WINTON Eliminated     32\n          JACKIE CHERRYHOMES Eliminated     31\n                    BOB FINE Eliminated     30\n                   DAN COHEN Eliminated     29\n          STEPHANIE WOODRUFF Eliminated     28\n             MARK V ANDERSON Eliminated     27\n                   DOUG MANN Eliminated     26\n                  OLE SAVIOR Eliminated     25\n               JAMES EVERETT Eliminated     24\n           ALICIA K. BENNETT Eliminated     23\n  ABDUL M RAHAMAN \"THE ROCK\" Eliminated     22\n        CAPTAIN JACK SPARROW Eliminated     21\n           CHRISTOPHER CLARK Eliminated     20\n                   TONY LANE Eliminated     19\n                JAYMIE KELLY Eliminated     18\n                  MIKE GOULD Eliminated     17\n             KURTIS W. HANNA Eliminated     16\n CHRISTOPHER ROBIN ZIMMERMAN Eliminated     15\n         JEFFREY ALAN WAGNER Eliminated     14\n                 NEAL BAXTER Eliminated     13\n            TROY BENJEGERDES Eliminated     12\n            GREGG A. IVERSON Eliminated     11\n            MERRILL ANDERSON Eliminated     10\n                  JOSHUA REA Eliminated      9\n                   BILL KAHN Eliminated      8\n         JOHN LESLIE HARTWIG Eliminated      7\n      EDMUND BERNARD BRUYERE Eliminated      6\nJAMES \"JIMMY\" L. STROUD, JR. Eliminated      5\n            RAHN V. WORKCUFF Eliminated      4\n       BOB \"AGAIN\" CARNEY JR Eliminated      3\n                  CYD GORMAN Eliminated      2\n         JOHN CHARLES WILSON Eliminated      1\n</code></pre> <p>And there you go! You've created a PreferenceProfile from real election data, done some cleaning, and then conducted an STV election. You can look at the offical results and confirm that <code>votekit</code> elected the same candidate as in the real 2013 election.</p>"},{"location":"some_plotting_options/","title":"Plotting, Summary Statistics, and More","text":"<p>In this tutorial we will explore various plotting options included in <code>votekit</code>. To do so, we will not use real election data, but rather some generated preference profiles. <code>votekit</code> offers support for the following kinds of ballot generating models: Plackett-Luce, Bradley-Terry, Alternating Crossover, a Cambridge Sampler (this one is custom!), 1-D Spatial, Impartial Culture, and Impartial Anonymous Culture.</p> <p>For simplicity, let's start with the Impartial Culture model, which assumes that when there are \\(m\\) candidates, a voter casts a ballot by choosing uniformly at random from the \\(m!\\) total linear orderings of the candidates.</p> <pre><code>import votekit.ballot_generator as bg\nfrom votekit.plots import plot_summary_stats, plot_MDS\nfrom votekit.graphs import PairwiseComparisonGraph, BallotGraph\nfrom votekit.metrics import earth_mover_dist, lp_dist\nfrom votekit import Ballot, PreferenceProfile\nfrom functools import partial\nfrom fractions import Fraction\n</code></pre> <pre><code># the list of candidates\ncandidates = [\"A\", \"B\", \"C\"]\n\n# initializing the ballot generator\nic = bg.ImpartialCulture(candidates=candidates)\n\n# generate 5 ballots under the IC model\nnumber_of_ballots = 5\nprofile = ic.generate_profile(number_of_ballots)\n\n# since this is a small preference profile, we can print the entire thing\nprint(profile)\n</code></pre> <pre><code>  Ballots  Weight\n(B, C, A)       1\n(A, B, C)       1\n(A, C, B)       1\n(B, A, C)       1\n(C, B, A)       1\n</code></pre> <p><code>votekit</code> comes with some basic summary statistics to help you analyze a profile. We can plot the number of first place votes each candidate received, the number of mentions they receive (i.e. the total number of times they appeared on a ballot), and a Borda count, which assigns \\(n-1\\) points to the first place winner of a ballot, \\(n-2\\) to the second place, ..., and 0 to the last place winner of a ballot.</p> <pre><code>fig = plot_summary_stats(profile, \"first place votes\", multi_color = False, title = \"First Place Votes\")\nfig = plot_summary_stats(profile, \"borda\", multi_color = False, title = \"Borda Scores\")\nfig = plot_summary_stats(profile, \"mentions\", multi_color = True, title = \"Mentions\")\n</code></pre> <p></p> <p></p> <p></p> <p>Check for understanding: In the IC model we are using, why is the number of mentions uniform?</p>"},{"location":"some_plotting_options/#graphs","title":"Graphs!","text":"<p>There are two kinds of graphs (networks) that <code>votekit</code> generates, a pairwise comparison graph, and a ballot graph. The former has vertices=candidates, and an edge going from A to B if A is preferred to B more often in the given preference profile. The edge is given weight equal to the number of times A is preferred to B minus the number of times B is preferred to A. You can learn about ballot graphs in the BallotGraph section.</p>"},{"location":"some_plotting_options/#pairwisecomparisongraph","title":"<code>PairwiseComparisonGraph</code>","text":"<p><code>PairwiseComparisonGraph</code> takes in a <code>PreferenceProfile</code>. There is an optional <code>ballot_length</code> parameter that determines the length of the ballot and then the <code>PairwiseComparisonGraph</code> graph will randomly fill in any ballots that are too short. Since we are using IC ballots which have a full linear ranking, we don't need to worry about that.</p> <pre><code>pwc_graph = PairwiseComparisonGraph(profile)\npwc_graph.draw()\n</code></pre> <p></p> <p>Check for understanding: are the edge weights what you expect given your <code>PreferenceProfile</code>?</p> <p><code>PairwiseComparisonGraph</code> has methods for computing dominating tiers and the existence of a condorcet winner. A dominating tier is a group of candidates that beats every candidate not in the set in a head-to-head comparison. A condorcet winner is a candidate who wins every head-to-head contest with every other candidate.</p> <pre><code>print(pwc_graph.dominating_tiers())\nprint()\nprint(pwc_graph.has_condorcet())\n</code></pre> <pre><code>[{'B'}, {'A'}, {'C'}]\n\nTrue\n</code></pre> <p><code>PairwiseComparisonGraph</code> also has a <code>compute_pairwise_dict</code> method which computes the edge weights for the graph, as well as <code>head2head_count</code> which computes the number of times that candidate A is preferred to candidate B.</p>"},{"location":"some_plotting_options/#mds-plots","title":"MDS Plots","text":"<p>One of the cool features of <code>votekit</code> is that we can create MDS plots, using different notions of distance between preference profiles. An MDS plot, in short, is a 2D representation of high dimensional data that attempts to minimize the distortion of the data. <code>votekit</code> comes with two distance metrics, the earthmover distance and the \\(L_p\\) distance.</p> <p>Let's explore how an MDS plot can show us the difference between different types of ballot generating models. We will explain what these generating models are doing in a different tutorial.</p> <pre><code>number_of_ballots = 1000\n\n\ncandidates = [\"W1\", \"W2\", \"C1\", \"C2\"]\nslate_to_candidate = {\"W\": [\"W1\", \"W2\"], \"C\": [\"C1\", \"C2\"]}\nbloc_crossover_rate = {\"W\": {\"C\": 0.3}, \"C\": {\"W\": 0.4}}\npref_interval_by_bloc = {\n    \"W\": {\"W1\": 0.4, \"W2\": 0.3, \"C1\": 0.2, \"C2\": 0.1},\n    \"C\": {\"W1\": 0.2, \"W2\": 0.2, \"C1\": 0.3, \"C2\": 0.3},\n}\nbloc_voter_prop = {\"W\": 0.7, \"C\": 0.3}\n\nic = bg.ImpartialCulture(candidates=candidates)\n\npl = bg.PlackettLuce(pref_interval_by_bloc=pref_interval_by_bloc,\n                     bloc_voter_prop=bloc_voter_prop, candidates=candidates)\n\nbt = bg.BradleyTerry(pref_interval_by_bloc=pref_interval_by_bloc,\n                     bloc_voter_prop=bloc_voter_prop, candidates=candidates)\n\nac = bg.AlternatingCrossover(pref_interval_by_bloc=pref_interval_by_bloc,\n                             bloc_voter_prop=bloc_voter_prop, candidates=candidates,\n                             slate_to_candidates=slate_to_candidate, bloc_crossover_rate=bloc_crossover_rate)\n</code></pre> <p><code>plot_MDS</code> takes in a <code>data</code> parameter, which is a dictionary whose keys are the colors you want to plot a particular list of <code>PreferenceProfiles</code> in and whose values are the lists of <code>PreferenceProfile</code> objects, a <code>distance</code> parameter that sets the metric between preference profiles, and <code>marker_size</code> which determines the size of the data points.</p> <pre><code># this allows us to generate 10 preference profiles under each ballot generator\nplot = plot_MDS(data = {'red': [ic.generate_profile(number_of_ballots) for i in range(10)], \n                        'blue': [pl.generate_profile(number_of_ballots) for i in range(10)], \n                        'green': [bt.generate_profile(number_of_ballots) for i in range(10)],\n                       'orange': [ac.generate_profile(number_of_ballots) for i in range(10)]},\n        distance = earth_mover_dist,\n               marker_size=100)\n</code></pre> <p></p> <p>Let's try a different metric.</p> <pre><code>plot = plot_MDS(data = {'red': [ic.generate_profile(number_of_ballots) for i in range(10)], \n                        'blue': [pl.generate_profile(number_of_ballots) for i in range(10)], \n                        'green': [bt.generate_profile(number_of_ballots) for i in range(10)],\n                       'orange': [ac.generate_profile(number_of_ballots) for i in range(10)]},\n        distance = lp_dist,\n               marker_size=100)\n</code></pre> <p></p> <p>By default, the \\(L_p\\) distance function uses \\(p=1\\). If you want to change that, we need the <code>partial</code> function from the <code>functools</code> module.</p> <pre><code>plot = plot_MDS(data = {'red': [ic.generate_profile(number_of_ballots) for i in range(10)], \n                        'blue': [pl.generate_profile(number_of_ballots) for i in range(10)], \n                        'green': [bt.generate_profile(number_of_ballots) for i in range(10)],\n                       'orange': [ac.generate_profile(number_of_ballots) for i in range(10)]},\n        distance = partial(lp_dist, p_value=2),\n               marker_size=100)\n</code></pre> <p></p> <p>Finally, to use the \\(L_\\infty\\) distance, use the keyword <code>inf</code>.</p> <pre><code>plot = plot_MDS(data = {'red': [ic.generate_profile(number_of_ballots) for i in range(10)], \n                        'blue': [pl.generate_profile(number_of_ballots) for i in range(10)], \n                        'green': [bt.generate_profile(number_of_ballots) for i in range(10)],\n                       'orange': [ac.generate_profile(number_of_ballots) for i in range(100)]},\n        distance = partial(lp_dist, p_value=\"inf\"),\n               marker_size=100)\n</code></pre> <p></p>"}]}